{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inici","text":""},{"location":"#resultats-daprenentatge","title":"Resultats d'aprenentatge","text":"<ul> <li>RA5. Genera diagrames de classes valorant la seua import\u00e0ncia en el desenvolupament d'aplicacions i emprant les eines disponibles en l'entorn.</li> <li>RA6. Genera diagrames de comportament valorant la seua import\u00e0ncia en el desenvolupament d'aplicacions i emprant les eines disponibles en l'entorn.</li> </ul>"},{"location":"#criteris-davaluacio","title":"Criteris d'avaluaci\u00f3","text":"<ul> <li>RA5.a) S'han identificat els conceptes b\u00e0sics de la programaci\u00f3 orientada a objectes.</li> <li>RA5.b) S'han utilitzat eines per a l'elaboraci\u00f3 de diagrames de classes.</li> <li>RA5.c) S'ha interpretat el significat de diagrames de classes.</li> <li>RA5.d) S'han tra\u00e7at diagrames de classes a partir de les especificacions de les mateixes.</li> <li>RA5.e) S'ha generat codi a partir d'un diagrama de classes.</li> <li> <p>RA5.f) S'ha generat un diagrama de classes mitjan\u00e7ant enginyeria inversa.</p> </li> <li> <p>RA6.a) S'han identificat els diferents tipus de diagrames de comportament.</p> </li> <li>RA6.b) S'ha reconegut el significat dels diagrames de casos d'\u00fas.</li> <li>RA6.c) S'han interpretat diagrames d'interacci\u00f3.</li> <li>RA6.d) S'han elaborat diagrames d'interacci\u00f3 senzills.</li> <li>RA6.e) S'ha interpretat el significat de diagrames d'activitats.</li> <li>RA6.f) S'han elaborat diagrames d'activitats senzills.</li> <li>RA6.g) S'han interpretat diagrames d'estats.</li> <li>RA6.h) S'han plantejat diagrames d'estats senzills.</li> </ul> <p>Comencem!</p>"},{"location":"1.UML/","title":"1. UML","text":""},{"location":"1.UML/#introduccio","title":"Introducci\u00f3","text":"<p>UML (Llenguatge Unificat de Modelat) \u00e9s un llenguatge universal (conjunt d'eines, majorit\u00e0riament gr\u00e0fiques i no lligat a cap llenguatge de programaci\u00f3 concret) que ens ajuda en el disseny de sistemes que plasmen idees d'una forma convencional i f\u00e0cil d'entendre per comunicar a altres persones.</p> <p>La versi\u00f3 actual del llenguatge \u00e9s la 2.5.1, publicada la seua \u00faltima revisi\u00f3 en desembre de 2017 (https://www.omg.org/spec/UML). Recentment, l'\u00fas de llenguatges per a la generaci\u00f3 din\u00e0mica de diagrames com Mermaid i PlantUML tamb\u00e9 ha guanyat popularitat, donant flexibilitat i integraci\u00f3 amb altres eines de documentaci\u00f3.</p> <p>Com vam veure a les primeres unitats, un dels principals problemes a l'hora d'abordar el desenvolupament de programari \u00e9s captar amb precisi\u00f3 all\u00f2 que desitja l'usuari. Per tal d'abordar aquest problema, i d'aportar un flux de treball coherent a l'hora de desenvolupar els sistemes, apareixen diferents metodologies de desenvolupament: Cascada, Espiral, amb Prototipat, metodologies \u00e0gils, etc. En aquestes metodologies, establ\u00edem diverses fases que abordaven la conceptualitzaci\u00f3 del sistema (fase d'an\u00e0lisi), el seu disseny, la implementaci\u00f3 i les proves i manteniment.</p> <p>El llenguatge UML no \u00e9s una metodologia en s\u00ed, sin\u00f3 un conjunt d'eines de suport per a aquestes fases de desenvolupament. En particular, eines com Umbrello UML i Mermaid poden complementar-se per generar diagrames \u00e0gils i adaptats als requeriments.</p> <p>Durant el que queda de curs, veurem UML com a suport per al desenvolupament de programari basant-nos en aquests models \u00e0gils, que van incorporant poc a poc noves funcionalitats.</p>"},{"location":"1.UML/#organitzacio-duml","title":"Organitzaci\u00f3 d'UML","text":"<p>UML es compon de diferents diagrames per tal de presentar diferents perspectives d'un sistema (models).</p> <p>UML 2.5 estableix dos tipus de diagrames principals: diagrames estructurals i diagrames de comportament. Jer\u00e0rquicament, podriem representar tots aquests diagrames de la seg\u00fcent forma (font: Wikipedia):</p> <p></p> <p>Veiem una descripci\u00f3 breu d'aquests diagrames:</p> <ul> <li> <p>Diagrames Estructurals: Representen l'estructura est\u00e0tica dels objectes en un sistema. Distingim els seg\u00fcents diagrames:</p> <ul> <li>Diagrama de classes: Es tracta del tipus de diagrama m\u00e9s utilitzat, i mostra les clases d'un sistema, junt amb els seus atributs i operacions, aix\u00ed com les relacions entre les diferents classes.</li> <li>Diagrama d'objectes o d'inst\u00e0ncia: Semblants als diagrames de classes, per\u00f2 fent \u00fas d'exemples concrets del m\u00f3n real. La seua utilitat \u00e9s saber com es vor\u00e0 un sistema en un moment donat.</li> <li>Diagrama de paquets: Mostra les depend\u00e8ncies entre els diferents paquets (packages) del nostre sistema.</li> <li>Diagrama de components: Mostra la relaci\u00f3 estructural dels diferents components d'un sistema de programari. S'utilitza principalment quan treballem amb sistemes complexos, formats per diferents subsistemes que es comuniquen entre s\u00ed mitjan\u00e7ant APIs. Un exemple podria ser una aplicaci\u00f3 client-servidor, on tindriem el component client i el component servidor.</li> <li>Diagrama de desplegament: Mostra el maquinari i programari en sistemes que requereixen de diversos equips, amb diferents configuracions.</li> <li>Diagrama de perfils: Permeten extendre l'UML per tal d'adaptar-se a una plataforma concreta de programaci\u00f3 (ja que no tots els llenguatges orientats a objectes s\u00f3n exactament iguals). Aix\u00ed, tindrem diagrames de perfils per a Java, C#, etc.</li> <li>Diagrama d'estructura composta: Mostren l'estructura interna d'una classe. \u00c9s semblant al diagrama de classes, per\u00f2 permet entrar m\u00e9s en detall en l'estructura interna d'alguns components.</li> </ul> </li> <li> <p>Diagrames de comportament: Mostren el comportament din\u00e0mic dels objectes en el sistema:</p> <ul> <li>Diagrama de casos d'\u00fas: Es tracta d'un dels diagrames m\u00e9s coneguts d'UML, i ofereixen una visi\u00f3 general dels actors (ja siguen usuaris o altres sistemes) involucrats en el sistema, i mostren les funcions que necessiten realitzar aquests en el sistema en desenvolupament i com interact\u00faen entre ells. \u00c9s un diagrama de gran utilitat quan comencem a desenvolupar un sistema, ja que ens permet identificar f\u00e0cilment els actors i els principals processos del sistema.</li> <li>Diagrama d'activitats: Mostren gr\u00e0ficament els fluxos de treball, tant a nivell empressarial com operatiu de qualsevol dels components del sistema.</li> <li>Diagrama de m\u00e0quina d'estats: Descriuen el comportament dels diferents objectes del sistema, en funci\u00f3 del seu estat.</li> <li>Diagrames d'interacci\u00f3:  Es tracta d'un subconjunt de diagrames de comportament que compr\u00e9n:<ul> <li>Diagrames de seq\u00fc\u00e8ncia: Mostren com interact\u00faen entre ells els diferents objectes del sistema en un escenari en particular. </li> <li>Diagrama de comunicaci\u00f3 (anteriorment anomenat diagrama de col\u00b7laboraci\u00f3): Semblant als diagrames de seq\u00fc\u00e8ncia, per\u00f2 centrant-se en els misstges que es passen els diferents objectes.</li> <li>Diagrama de temps: Representen el comportament dels objectes en un marc de temps donat. </li> <li>Diagrama global d'interaccions: Molt semblants als diagrames d'activitat, per\u00f2 mostrant una seq\u00fc\u00e8ncia de diagrames d'interacci\u00f3. Podem dir que es tracta d'una col\u00b7lecci\u00f3 de diagrames d'interacci\u00f3 i l'ordre en qu\u00e8 aquestes ocorren.</li> </ul> </li> </ul> </li> </ul> <p>Con\u00e9ixer tots aquests diagrames i saber desenvolupar-los \u00e9s feina dels enginyers de programari. Al nostre cas, anem a familiaritzar-nos amb els principals diagrames, per tal de poder entendre'ls i implementar-los, aix\u00ed com realitzar modificacions per tal d'ampliar la funcionalitat d'un sistema. Con\u00e9ixer-los ens servir\u00e0 tamb\u00e9 per aprofundir en el nostre coneixement sobre la programaci\u00f3 orientada a objecte i l'organitzaci\u00f3 del programari.</p>"},{"location":"1.UML/#eines-case-i-de-documentacio-umbrello-uml-mermaid-i-plantuml","title":"Eines CASE i de documentaci\u00f3: Umbrello UML, Mermaid i PlantUML","text":"<p>Les eines CASE (Computer-Aided Software Engineering o Enginyeria del programari assistida per ordinador) son un conjunt d'eines inform\u00e0tiques que ajuden en les diferents fases del cicle de vida del programari, incloent:</p> <ol> <li>Disseny: Creaci\u00f3 de diagrames UML, estructures de dades, o models d'arquitectura.</li> <li>Documentaci\u00f3: Generaci\u00f3 autom\u00e0tica de documentaci\u00f3 a partir dels models creats.</li> <li>Codificaci\u00f3: Generaci\u00f3 de codi base a partir dels models o diagrames (per exemple, generar esquelets de classes).</li> <li>Proves: Suport en la generaci\u00f3 de casos de prova i l'automatitzaci\u00f3 del proc\u00e9s de proves.</li> <li>Manteniment: Permet actualitzar diagrames i models a mesura que el sistema evoluciona.</li> </ol> <p>Algunes de les eines CASE que podem trobar, i les principals caracter\u00edstiques s\u00f3n:</p> <ul> <li>Dia: Senzill, simple i vers\u00e0til. Permet la generaci\u00f3 de codi (Java, Python, C/C++) a partir dels diagrames de classes. No suporta UML2. Multiplataforma. Programari lliure.</li> <li>Argo UML: Permet la generaci\u00f3 de codi Java a partir dels diagrames de classes. No suporta UML2. Multiplataforma. T\u00e9 un gran inconvenient: no t\u00e9 l\u2019opci\u00f3 de desfer (undo).</li> <li>Microsoft Visio: Permet fer varis tipus de diagrames UML.</li> <li>Visual Paradigm: Molt complet i intu\u00eftiu. S\u2019integra amb Eclipse i Netbeans, per\u00f2 les caracter\u00edstiques avan\u00e7ades com la generaci\u00f3 de codi i l\u2019enginyeria inversa (crear el diagrama a partir del codi) necessiten una llic\u00e8ncia de pagament.</li> <li>Papyrus: Complement d\u2019Eclipse, gratu\u00eft per\u00f2 molt complex.</li> <li>Object Aid: Plugin d\u2019Eclipse. Genera diagrames de classe per mitj\u00e0 d\u2019enginyeria inversa i, amb la versi\u00f3 de pagament, tamb\u00e9 diagrames de seq\u00fc\u00e8ncia.</li> <li>EasyUML: Plugin de NetBeans. Nom\u00e9s permet la creaci\u00f3 de diagrames de classe.</li> </ul> <p>Una altra eina, que \u00e9s la que utilitzarem \u00e9s Umbrello UML Modeller, disponible directament des dels repositoris d'Ubuntu, i que forma part del conjunt d'eines de KDE. </p>"},{"location":"1.UML/#umbrello-uml","title":"Umbrello UML","text":"<p>Umbrello UML Modeller \u00e9s una eina CASE que ens ajuda a generar diagrames UML i estructurar el nostre programari. \u00c9s lliure i de codi obert, disponible per a diverses plataformes. Aquesta eina permet:</p> <ul> <li>Crear diagrames de casos d'\u00fas i classes, entre d'altres.</li> <li>Generar codi base a partir dels diagrames creats.</li> <li>Documentar sistemes de forma visual.</li> </ul> <p>Podeu instal\u00b7lar-lo en Ubuntu amb:</p> <pre><code>sudo apt install umbrello\n</code></pre> <p>O descarregar-lo des de la seua p\u00e0gina oficial: https://umbrello.kde.org/.</p> <p>Com comenta a la web, Umbrello UML Modeller \u00e9s una eina de programari lliure per a la realitzaci\u00f3 de diagrames UML, que permet crear diagrames de programari i altres sistemes per tal de dissenyar la documentaci\u00f3 i l'estructura de les nostres aplicacions.</p> <p>Una vegada instal\u00b7lat, quan obrim Umbrello UML Modeller trobarem una interf\u00edcie semblant a la seg\u00fcent:</p> <p></p> <p>Com podem veure, a la part de l'esquerra se'ns mostren diferents carpetes per a les diferents vistes de la nostra aplicaci\u00f3. Cada vista contindr\u00e0 un o diversos tipus de diagrames. Els diagrames que utilitzarem en aquesta unitat ser\u00e0 el diagrama de casos d'\u00fas (Vista casos d'\u00fas), i els diagrames de classes (Vista l\u00f2gica).</p> <p>Es tracta d'una aplicaci\u00f3 bastant senzilla, que ens permet anar creant els diagrames incorporant els diferents elements i establint les relacions entre ells. A m\u00e9s, tamb\u00e9 ens permetr\u00e0 generar el codi de base per a les nostres aplicacions.</p> <p>Podeu consultar tota la informaci\u00f3 sobre com generar diagrames UML des del seu complet manual: https://docs.kde.org/stable5/en/umbrello/umbrello/index.html.</p>"},{"location":"1.UML/#mermaid","title":"Mermaid","text":"<p>Mermaid \u00e9s un llenguatge basat en text per generar diagrames de forma din\u00e0mica i integrar-los amb plataformes de documentaci\u00f3 en combinaci\u00f3 amb Markdown, com puguen ser GitHub, Obsidian o Docusaurus.</p> <p>Amb Mermaid podrem generar diagrames UML de manera f\u00e0cil i r\u00e0pida, directament des del codi, sent multiplataforma i f\u00e0cil d'instal\u00b7lar.</p>"},{"location":"1.UML/#installacio","title":"Instal\u00b7laci\u00f3","text":"<p>No cal fer ...</p> <ul> <li>Aquesta instal\u00b7laci\u00f3 no cal fer-la ja que el plugin de PlantUML, que instal\u00b7larem despr\u00e9s, ja renderitza sintaxi mermaid.</li> </ul> <p>La instal\u00b7laci\u00f3 de <code>mermaid</code> es realitza de manera global mitjan\u00e7ant NPM, el gestor de paquets de node:</p> <pre><code>npm install -g @mermaid-js/mermaid-cli\n</code></pre>"},{"location":"1.UML/#introduccio-a-la-sintaxi-de-mermaid","title":"Introducci\u00f3 a la sintaxi de Mermaid","text":"<p>La sintaxi de Mermaid \u00e9s senzilla i es basa en text per definir entitats, processos i connexions. A continuaci\u00f3, es detallen algunes caracter\u00edstiques clau:</p> <ul> <li> <p>Tipus de diagrama: Sempre es defineixen al principi del codi. Alguns exemples de tipus de diagrama poden ser:</p> <ul> <li><code>flowchart TD</code>: Diagrama de flux amb direcci\u00f3 de dalt a baix (Top to Down).</li> <li><code>flowchart LR</code>: Flux d'esquerra a dreta (Left to Right).</li> <li><code>flowchart RL</code>: Flux de dreta a esquerra (Right to Left).</li> <li><code>flowchart BT</code>: Flux de baix a dalt (Bottom to Top).</li> </ul> </li> <li> <p>Entitats: Es defineixen amb un identificador i el contingut entre claud\u00e0tors o par\u00e8ntesis:</p> <ul> <li><code>[Entitat]</code> per caixes.</li> <li><code>(Proc\u00e9s)</code> per processos o decisions.</li> </ul> </li> <li> <p>Connexions:</p> <ul> <li><code>--&gt;</code> indica una connexi\u00f3 simple.</li> <li><code>-- text --&gt;</code> permet afegir etiquetes a les connexions.</li> <li><code>---</code> representa una connexi\u00f3 sense direcci\u00f3.</li> </ul> </li> <li> <p>Condicions: Es representen amb rombs i es poden connectar amb diferents camins segons la l\u00f2gica.</p> </li> </ul>"},{"location":"1.UML/#tipus-de-diagrames-compatibles","title":"Tipus de diagrames compatibles","text":"<p>Mermaid suporta diferents tipus de diagrames (no nom\u00e9s UML), com puguen ser:</p> <ul> <li>Diagrames de flux (flowcharts).</li> <li>Diagrames de classes.</li> <li>Diagrames de seq\u00fc\u00e8ncia.</li> <li>Diagrames de Gantt.</li> <li>Diagrames d'estats.</li> </ul>"},{"location":"1.UML/#exemple-de-codi-mermaid","title":"Exemple de codi Mermaid","text":"<p>Veiem alguns exemples de codi amb mermaid:</p> <ul> <li>Exemple de diagrama de flux. El seg\u00fcent codi Markdown:</li> </ul> <pre><code>```mermaid\nflowchart TD\n    A[Inici del proc\u00e9s] --&gt; B{Es compleix la condici\u00f3?}\n    B -- S\u00ed --&gt; C[Executa l'acci\u00f3 A]\n    B -- No --&gt; D[Executa l'acci\u00f3 B]\n    C --&gt; E[F\u00ed del proc\u00e9s]\n    D --&gt; E\n```\n</code></pre> <p>Genera el seg\u00fcent diagrama de flux:</p> <pre><code>flowchart TD\n    A[Inici del proc\u00e9s] --&gt; B{Es compleix la condici\u00f3?}\n    B -- S\u00ed --&gt; C[Executa l'acci\u00f3 A]\n    B -- No --&gt; D[Executa l'acci\u00f3 B]\n    C --&gt; E[F\u00ed del proc\u00e9s]\n    D --&gt; E</code></pre> <ul> <li>Exemple de diagrama de classes. El seg\u00fcent codi Markdown:</li> </ul> <pre><code>```mermaid\nclassDiagram\n    class Producte {\n        - String descripci\u00f3\n        - float preu\n        + String ObteLiniaProducte()\n    }\n    class Cistella {\n        - List&lt;Producte&gt; productes\n        - float preuTotal\n        + void AfigProducte(Producte)\n        + void MostraCistella()\n    }\n    Cistella \"1\" o-- \"0..*\" Producte\n\n```\n</code></pre> <p>Generar\u00e0 un diagrama com aquest:</p> <pre><code>\nclassDiagram\n    class Producte {\n        - String descripci\u00f3\n        - float preu\n        - int quantitat\n        + String ObteLiniaProducte()\n    }\n    class Cistella {\n        - List&lt;Producte&gt; productes\n        - float preuTotal\n        + void AfigProducte(Producte)\n        + void MostraCistella()\n    }\n    Cistella \"1\" o-- \"0..*\" Producte    </code></pre>"},{"location":"1.UML/#plantuml","title":"PlantUML","text":"<p>PlantUML \u00e9s una eina m\u00e9s completa i expressiva, que ens permet generar una varietat m\u00e9s \u00e0mplia de diagrames espec\u00edfics d'UML (classes, seq\u00fc\u00e8ncia, activitat, components, desplegament, etc.).</p> <p>A m\u00e9s, ofereix una major flexibilitat per representar estructures complexes, com patrons de disseny o gen\u00e8rics.</p> <p>Per altra banda, PlantUML tamb\u00e9 s'integra amb entorns de desenvolupament com IntelliJ, Eclipse o VSCode.</p>"},{"location":"1.UML/#installacio_1","title":"Instal\u00b7laci\u00f3","text":"<p>PlantUML es distribueix com un arxiu Java (JAR - Java ARchive), pel que requereix d'un entorn d'execuci\u00f3 de Java (JRE).</p> <p>Podem descarregar el fitxer JAR i els fonts des de https://plantuml.com/download.</p> <p>Al nostre cas, descarregarem el fitxer amb llic\u00e8ncia GPL. Una vegada descarregat (podem deixar-lo a la nostra carpeta <code>~/devtools</code>), l'executarem amb:</p> <pre><code>java -jar plantuml-1.2025.0.jar\n</code></pre> <p>Aquesta eina ens permetr\u00e0 obrir fitxers amb diverses extensions i representar diagrames.</p> <p>Per exemple, creem un fitxer markdown amb el seg\u00fcent contingut. Observeu que el diagrama comen\u00e7a amb <code>@startuml</code> i acaba amb <code>@enduml</code>:</p> <p><pre><code>` ``plantuml\n@startuml\nclass Producte {\n    -String descripci\u00f3\n    -float preu\n    -int quantitat\n    +String ObteLiniaProducte()\n}\n\nclass Cistella {\n    -List&lt;Producte&gt; productes\n    -float preuTotal\n    +void AfigProducte(Producte)\n    +void MostraCistella()\n}\n\nCistella \"1\" o-- \"0..*\" Producte\n@enduml\n` ``\n</code></pre> Aix\u00f2 ens genera el seg\u00fcen diagrama:</p> <p></p>"},{"location":"1.UML/#extensions-per-a-vscode","title":"Extensions per a VSCode","text":"<p>L'extensi\u00f3 PlantUML ens servir\u00e0 per donar suport a aquest llenguatge en VSCode, amb remarcat de sintaxi i previsualitzaci\u00f3 de diagrames.</p> <p></p> <p>Aquesta extensi\u00f3 permet processar el diagrama b\u00e9 fent \u00fas d'un servidor, o b\u00e9 fent \u00fas del JAR que tinguem al nostre equip. Per a aquesta segona opci\u00f3, hem d'ajustar el par\u00e0metre plantuml-jar amb la ruta on tenim el JAR del PlantUML:</p> <p></p> <p>Recordeu que per configurar estos par\u00e0metres ho fem a trav\u00e9s de File &gt; Preferences &gt; Settings. </p> <p>Amb aix\u00f2, podem pr\u00e9mer <code>Ctrl + D</code> per tal de previsualitzar els diagrames que tinguem en format PlantUML.</p> <p>Ara b\u00e9, l'extensi\u00f3 PlantUML per ella mateixa no renderitza PlantUML dins de Markdown. Cal una extensi\u00f3 que permeta treballar amb Markdown i reconega blocs PlantUML, com ara Markdown Preview Enhanced, que a m\u00e9s, tamb\u00e9 reconeix Mermaid:</p> <p></p> <p>Aix\u00ed doncs, instal\u00b7lem l'extensi\u00f3, i una vegada instal\u00b7lada, hem de configurar-la amb la ruta al fitxer JAR que hem descarregat abans, ja que tamb\u00e9 necessita d'aquest per poder renderitzar blocs PlantUML.</p> <p>Per a aix\u00f2, anirem de nou a les opcions de configuraci\u00f3 (File &gt; Preferences &gt; Settings), i buscarem el par\u00e0metre <code>markdown-preview-enhanced.plantumlJarPath</code> per afegir-li la ruta absoluta al fitxer JAR que hem descarregat:</p> <p></p> <p>Graphivz</p> <p>Si no es renderitzen els diagrames i s'indica un missatge en relaci\u00f3 al directori \"/opt/local/bin/dot\" significa que haur\u00e0s d'instal\u00b7lar el programa dot, que es part de Graphviz, una ferramienta necess\u00e0ria prr a renderitzar els diagramas. Ho farem amb \"sudo apt install graphviz\". </p> <p>Una vegada instalat, comprova que s'ha fet correctament (\"dot -version\"), reinicia Visual Code Studio i els diagrames ja s'haurien de renderitzar.</p> <p>Documentaci\u00f3 de Mermaid i PlantUML</p> <ul> <li> <p>Al seg\u00fcent enlla\u00e7 podeu trobar una guia sobre la implementaci\u00f3 dels diferents diagrames amb Mermaid.</p> </li> <li> <p>La documentaci\u00f3 oficial de PlantUML ens ofereix informaci\u00f3 sobre tots els diagrames que soporta.</p> </li> </ul> <p>Fins aci hem vist qu\u00e8 \u00e9s UML i diverses eines per tal de generar diagrames. Als seg\u00fcents apartats ens centrarem principalment en algun tipus de diagrames concrets, per tal de modelar el comportament, les classes i els components.</p>"},{"location":"10.Sprint4/","title":"10.Sprint4","text":""},{"location":"10.Sprint4/#sprint-4-noves-funcionalitats-enunciat","title":"Sprint 4. Noves funcionalitats. Enunciat","text":"<p>Se'ns demana afegir un parell de noves funcionalitats a la nostra aplicaci\u00f3 per realitzar comandes on-line per a una pizzeria. Aquestes noves funcionalitats seran:</p> <ul> <li>Incorporar la possibilitat de demanar begudes, a trav\u00e9s d'una pestanya, igual que es fa amb les pizzes i els entrants.</li> <li>Una vegada es tinga tota la comanda, s'envia aquesta al servidor, qui processar\u00e0 la petici\u00f3 i retornar\u00e0 una confirmaci\u00f3 amb l'hora estimada d'arribada de la comanda. L'aplicaci\u00f3 guardar\u00e0 un registre de les comandes realitzades.</li> </ul> <p>A continuaci\u00f3 es comenten alguns detalls sobre aquests dos requeriments:</p>"},{"location":"10.Sprint4/#demanar-begudes","title":"Demanar begudes","text":"<p>L'equip de disseny ens proporciona el seg\u00fcent mockup de com quedaria una vista amb la informaci\u00f3 sobre les begudes.</p> <p></p> <p>La informaci\u00f3 sobre les begudes s'obtindr\u00e0 del servidor <code>https://pizza-rest-server-production.up.railway.app/api/pizzeria/beguda</code> (aix\u00f2 ara \u00e9s irrellevant), i cada beguda contindr\u00e0 informaci\u00f3 com la seg\u00fcent:</p> <pre><code>{\n  \"id\": \"cola0\",\n  \"nom\": \"Coca Cola Zero 33 cl\",\n  \"preu\": 1.6,\n  \"sucre\": false,\n  \"cafeina\": true,\n  \"alcohol\": false\n}\n</code></pre> <p>El funcionament ser\u00e0 semblant al que tenim en pizzes i entrants, de manera que el elient podr\u00e0 afegir o eliminar begudes al carret.</p>"},{"location":"10.Sprint4/#processament-de-la-comanda","title":"Processament de la comanda","text":"<p>Una vegada realitzada, el client podr\u00e0 enviar la comanda a la pizzeria. Per a aix\u00f2 disposar\u00e0 d'un bot\u00f3 a la part inferior d'aquesta:</p> <p></p> <p>Quan la petici\u00f3 s'envie, poden passar dues coses, o b\u00e9 que es produisca algun error (cosa que s'haur\u00e0 de considerar en l'app client):</p> <p></p> <p>O b\u00e9 que la petici\u00f3 tinga \u00e8xit. En aquest cas, el servidor ens retornar\u00e0 una resposta amb el format:</p> <pre><code>{\n    \"confirmed\":true,\n    \"time\":\"17:02\",\n    \"order\":27\n}\n</code></pre> <p>Mostrant que la petici\u00f3 \u00e9s confirmada, el n\u00famero de comanda (<code>order</code>), i l'hora prevista d'arribada (<code>time</code>).</p> <p>Aquesta es mostrar\u00e0 a l'usuari amb un missatge:</p> <p></p> <p>En cas que es detecte un error en el servidor, el missatge que retornar\u00e0 contindr\u00e0:</p> <pre><code>{\n    \"confirmed\":false,\n    \"message\":\"Missatge d'error\"\n}\n</code></pre> <p>Finalment, una vegada la comanda s'ha enviat, s'esborra el contingut del carret, i s'afegir\u00e0 la comanda a l'hist\u00f2ric de comandes, que es podr\u00e0 consultar des d'una altra pestanya, amb el seg\u00fcent aspecte:</p> <p></p> <p>Com veiem, consisteix en una Card amb el n\u00famero de comanda, l'hora d'arribada i la llista de productes de l'enc\u00e0rrec.</p>"},{"location":"10.Sprint4/#requeriments","title":"Requeriments","text":"<p>Es demana:</p> <ol> <li>Ampliaci\u00f3 del diagrama de casos d'\u00fas, contemplant els anteriors</li> <li>Especificaci\u00f3 dels requisits funcionals per als dos casos anteriors (nom, actors, descripci\u00f3, precondicions, postcondicions, flux principal i fluxos alternatius/excepcions)</li> <li>Ampliaci\u00f3 del diagrama de classes, incorporant noves classes i les modificacions que puguen haver en altres classes.</li> <li>Diagrames de seq\u00fc\u00e8ncia per a cada operaci\u00f3</li> </ol>"},{"location":"10.Sprint4/#estat-actual-del-sistema","title":"Estat actual del sistema","text":"<p>A mode d'exemple, veiem els diagrames UML m\u00e9s representatius del qu\u00e8 tenim fins a l'sprint 3.</p>"},{"location":"10.Sprint4/#diagrama-de-casos-dus","title":"Diagrama de casos d'\u00fas","text":""},{"location":"10.Sprint4/#diagrama-de-classes","title":"Diagrama de classes","text":""},{"location":"10.Sprint4/#diagrama-de-sequencia-dexemple-afegir-entrant","title":"Diagrama de seq\u00fc\u00e8ncia d'exemple (afegir entrant)","text":""},{"location":"10.Sprint4/#diagrama-de-components","title":"Diagrama de components","text":"<p>Ves a la soluci\u00f3!</p>"},{"location":"2.DiagramesCasosUs/","title":"2. Diagrama de casos d'us","text":""},{"location":"2.DiagramesCasosUs/#diagrames-de-casos-dus","title":"Diagrames de casos d'\u00fas","text":"<p>Els diagrames de casos d'\u00fas s\u00f3n els diagrames m\u00e9s coneguts d'UML i representen els diferents actors externs que interactuen amb el sistema d'informaci\u00f3, i a trav\u00e9s de quines funcionalitats (casos d'\u00fas o requeriments funcionals) es relacionen amb ell.</p> <p>\u00c9s a dir, aquests diagrames ens mostraran de manera visual les diferents funcions que pot realitzar cada tipus d'usuari d'un sistema d'informaci\u00f3.</p> <p>Les finalitats dels diagrames de casos d'\u00fas poden ser diverses, i entre elles podem trobar:</p> <ul> <li>Representar els requeriments funcionals del sistema (qu\u00e8 volem que fa\u00e7a).</li> <li>Representar els actors que es comuniquen amb el sistema. Aquests actors seran b\u00e9 usuaris (perfils d'usuaris m\u00e9s concretament) o altres sistemes externs.</li> <li>Representar la relaci\u00f3 entre els requeriments funcionals  i els actors.</li> <li>Guiar el desenvolupament del sistema, donant-nos un punt de partida sobre qu\u00e8 comen\u00e7ar a desenvolupar.</li> <li>Facilitar la comunicaci\u00f3 precisa entre client i desenvolupador, simplificant la forma en qu\u00e8 tots puguen participar en l'elaboraci\u00f3 dels requeriments del sistema, inclosos els clients.</li> </ul>"},{"location":"2.DiagramesCasosUs/#elements-dun-diagrama-de-casos-dus","title":"Elements d'un diagrama de casos d'\u00fas","text":"<p>Els diagrames de casos d'\u00fas es componen de tres elements principals: els actors, els casos d'\u00fas i les relacions.</p>"},{"location":"2.DiagramesCasosUs/#actors","title":"Actors","text":"<p>Els actors s\u00f3n entitats, ja siguen persones o no, externes al sistema, i que interactuen amb ell de forma directa. Aquesta interacci\u00f3 es tradueix en que aporten o reben informaci\u00f3, que realitzen una acci\u00f3, etc.</p> <p>Els actors es representen de forma senzilla com un monigot (no he trobat altra definici\u00f3 m\u00e9s clara), amb el nom de l'actor al davall:</p> <p></p> <p>Com hem dit, distingim dos tipus d'actors: usuaris i sistemes. A m\u00e9s, els usuaris no s\u00f3n usuaris concrets, sin\u00f3 tipus, rols o perfils d'usuari (usuari, administrador, gerent, gestor, etc.). Pel que fa als actors que s\u00f3n sistemes, aquests poden ser, per exemple, sistemes de gesti\u00f3 de bases de dades o el sistema de fitxers on emmagatzemem informaci\u00f3. En ocasions, quan es tracta d'actors que s\u00f3n altres sistemes, no s'utilitza la notaci\u00f3 del ninot, per ser poc intu\u00eftiva.</p> <p>Representaci\u00f3 d'actors en Mermaid i PlantUML</p> <p>En Mermaid i PlantUML representem els actors de la seg\u00fcent forma:</p> <ul> <li>Mermaid:</li> </ul> <pre><code>```mermaid\ngraph TD\n    A[Actor]\n```\n</code></pre> <pre><code>graph TD\n    A[Actor]</code></pre> <ul> <li>PlantUML</li> </ul> <pre><code>``` plantuml\n@startuml\n:Actor:\n@enduml\n```\n</code></pre> <p></p>"},{"location":"2.DiagramesCasosUs/#casos-dus","title":"Casos d'\u00fas","text":"<p>Un cas d'\u00fas representa una funcionalitat (o unitat de funcionalitat completa) que realitza el sistema, i es tracta d'una seq\u00fc\u00e8ncia d'accions que fa el sistema i que produeixen un resultat que puga percebre i siga d'utilitat per a algun dels actors.</p> <p>La seua representaci\u00f3 gr\u00e0fica \u00e9s una el\u00b7lipse, amb el nom del cas d'\u00fas a dins. Com hem dit, s\u00f3n accions que realitzar\u00e0 el sistema; alguns exemples poden ser:  \"Realitzar Comanda\", \"Llistar productes\", \"Enviar missatge\".</p> <p>Abans de l'especificaci\u00f3 d'UML 2.5 els casos d'\u00fas els havia d'invocar un actor. A partir de la versi\u00f3 2.5, es contempla que algunes funcionalitats del sistema les inicie el propi sistema, i al mateix temps, oferisca resultats \u00fatils al client (per exemple, accions peri\u00f2diques que realitze el sistema de forma autom\u00e0tica, com comprovar si hi ha correus nous o actualitzar informaci\u00f3 meteorol\u00f2gica).</p> <p>Casos d'\u00fas en Mermaid i PlantUML</p> <ul> <li>Mermaid</li> </ul> <p><pre><code>```mermaid\ngraph TD\n    U((Cas d'\u00fas))\n```\n</code></pre> <pre><code>graph TD\n    U((Cas d'\u00fas))</code></pre></p> <ul> <li>PlantUML:</li> </ul> <pre><code>``` plantuml\n@startuml\n(Realitzar Comanda)\n@enduml\n```\n</code></pre> <p></p>"},{"location":"2.DiagramesCasosUs/#relacions","title":"Relacions","text":"<p>Les relacions connecten els casos d'\u00fas amb els actors, o els casos d'\u00fas entre si.</p> <p>Aquestes connexions representen la interacci\u00f3 entre l'actor i el cas d'\u00fas, i sol representar-se amb una l\u00ednia cont\u00ednua amb la identificaci\u00f3 <code>&lt;&lt;comunicates&gt;&gt;</code>.</p> <p>Quan connectem casos d'\u00fas entre ells podem diferenciar dos tipus de relacions: <code>&lt;&lt;include&gt;&gt;</code> i <code>&lt;&lt;extend&gt;&gt;</code> (o b\u00e9 les traduccions <code>&lt;&lt;usa&gt;&gt;</code> i <code>&lt;&lt;est\u00e9n&gt;&gt;</code>):</p> <ul> <li> <p><code>&lt;&lt;include&gt;&gt;</code>: Indica que un cas d'\u00fas utilitza sempre altre cas d'\u00fas obligat\u00f2riament. Es representa amb una fletxa discont\u00ednua, que va des del cas d'\u00fas d'origen al cas d'\u00fas que s'inclou.</p> </li> <li> <p><code>&lt;&lt;extend&gt;&gt;</code>: S'utilitza quan un cas d'us t\u00e9 un comportament opcional que est\u00e0 contemplat en altre cas d'\u00fas. Es representa amb una fletxa discont\u00ednua, des del cas d'\u00fas opcional a l'original.</p> </li> </ul> <p>A m\u00e9s, hi ha altre tipus de relaci\u00f3 anomenada generalitzaci\u00f3, consistent a que un element hereta el comportament d'un altre. Tot i que podem utilitzar-ho en casos d'\u00fas, el m\u00e9s habitual \u00e9s fer-ho entre actors, per exemple, per indicar que un usuari administrador d'una aplicaci\u00f3 tamb\u00e9 pot ser usuari corrent, i heretar les funcionalitats d'aquest.</p> <p>Relacions en Mermaid i PlantUML</p> <p>Mermaid</p> <p>Mermaid no disposa d'elements espec\u00edfics pe a expressar relacions entre actors i entitats, sin\u00f2 que fa \u00fas de connexions. </p> <ul> <li>Per tal d'indicar una fletxa cont\u00ednua, quan un Actor es relaciona amb un cas d'\u00fas, fem \u00fas de <code>--&gt;</code>.</li> <li>Per tal d'indicar fletxes discont\u00ednues entre casos d'\u00fas fem \u00fas de <code>-..-&gt;</code>. </li> <li>A m\u00e9s, a dins la fletxa podem incorporar anotacions, que en el cas de les relacions entre casos d'\u00fas ens serviran per indicar el tipus, si \u00e9s use, extends o include, amb <code>-.use.-&gt;</code>, <code>-.extend.-&gt;</code> i <code>-.use.-&gt;</code> (sense espais).</li> </ul> <p>Veiem un exemple:</p> <pre><code>```mermaid\ngraph LR\n    Actor --&gt; Cas1((Cas d'\u00fas 1))\n    Cas1 - .include.-&gt; Cas2((Cas d'\u00fas 2))\n    Cas3((Cas d'\u00fas 3)) - .extend.-&gt; Cas2\n```\n</code></pre> <pre><code>graph LR\n    Actor --&gt; Cas1((Cas d'\u00fas 1))\n    Cas1 -.include.-&gt; Cas2((Cas d'\u00fas 2))\n    Cas3((Cas d'\u00fas 3)) -.extend.-&gt; Cas2</code></pre> <p>PlantUML, per la seua banda, s\u00ed que aporta una major riquesa expressiva. En aquest cas:</p> <ul> <li>Les relacions entre actors i casos d'\u00fas s'expressen amb <code>--&gt;</code>.</li> <li>Les relacions entre casos d'\u00fas, si s\u00f3n d'inclussi\u00f3 (includes) s'expressen amb <code>.&gt;</code>. A m\u00e9s, podem afegir al final l'etiquea <code>&lt;&lt;include&gt;&gt;</code>, per indicar que un cas d'\u00fas sempre utilitza un altre cas d'\u00fas com a part del seu comportament.</li> <li>Les relacions d'extensi\u00f3 (extends) entre casos d'\u00fas s'expressen amb <code>..&gt;</code>. A m\u00e9s, podem incloure l'etiqueta <code>&lt;&lt;extends&gt;&gt;</code> al final.</li> </ul> <pre><code>``` plantuml\n@startuml\n:Actor: --&gt; (Cas d'\u00fas 1)\n(Cas d'\u00fas 1) .&gt; (Cas d'\u00fas 2) : &lt;&lt;include&gt;&gt;\n(Cas d'\u00fas 3) ..&gt; (Cas d'\u00fas 2) : &lt;&lt;extend&gt;&gt;\n@enduml\n```\n</code></pre> <p></p>"},{"location":"2.DiagramesCasosUs/#exemple-un-carret-de-la-compra","title":"Exemple: Un carret de la compra","text":"<p>El seg\u00fcent diagrama de casos d'\u00fas mostra els elements vistos anteriorment en el context d'una aplicaci\u00f3 t\u00edpica de carret de la compra en una plataforma de compres on-line.</p> <p></p> <p>Com veiem, tenim dos classes d'actors: <code>Client</code> i <code>Encarregat</code>, sent el segon un cas especial del primer, ja que un encarregat de la plataforma pot ser tamb\u00e9 un client.</p> <p>Pel que fa als casos d'\u00fas associats al client, se'ns mostren dos: * <code>Afig producte</code> al carret de la compra, i * <code>Realitza enc\u00e0rrec</code>, una vegada el client t\u00e9 el carret preparat. Per tal de poder realitzar efectivament l'enc\u00e0rrec, cal que el client es valide de nou, pel que aquest cas d'\u00fas fa \u00fas (<code>&lt;&lt;includes&gt;&gt;</code>) del cas <code>Valida usuari</code>.</p> <p>Per la seua banda, l'actor Encarregat, t\u00e9 associat el cas d'\u00fas:</p> <ul> <li><code>Preparar Enc\u00e0rrec</code>, que requerir\u00e0, una vegada s'envie el paquet a l'usuari notificar aquest b\u00e9 a trav\u00e9s de correu electr\u00f2nic o b\u00e9 pe SMS. Per a aix\u00f2, apareixen dos casos nous d'\u00fas <code>Enviar correu</code> i <code>Enviar SMS</code>, que seran opcionals (<code>&lt;&lt;extend&gt;&gt;</code>).</li> </ul>"},{"location":"2.DiagramesCasosUs/#exemple-amb-mermaid","title":"Exemple amb Mermaid","text":"<p>Veiem aquest mateix exemple com es podria expressar amb Mermaid:</p> <pre><code>```mermaid\ngraph LR\n    Client[Client] --&gt; AfigProducte((Afig producte))\n    Client --&gt; RealitzaEncarrec((Realitza enc\u00e0rrec))\n    Encarregat -..-&gt;|Generalitzaci\u00f3| Client\n    RealitzaEncarrec - .include.-&gt; ValidaUsuari((Valida usuari))\n\n    Encarregat[Encarregat] --&gt; PrepararEncarrec((Preparar enc\u00e0rrec))\n        EnviarCorreu((Enviar correu)) --.extend.-&gt; PrepararEncarrec\n    EnviarSMS((Enviar SMS)) - .extend.-&gt; PrepararEncarrec\n```\n</code></pre> <p>Com veiem, Mermaid defineix el diagrama com un diagrama de Flux (<code>graph</code>), ja que no disposa d'un tipus de diagrama espec\u00edfic per a casos d'\u00fas.</p> <p>En aquest diagrama, els nodes defineixen tant els actors com els casos d'\u00fas, i es distingeixen pel seu estil visual, de la seg\u00fcent manera:</p> <ul> <li>Els nodes que defineixen un actor s'expressen com a <code>Actor[Actor]</code>. El primer element d'aquests \u00e9s l'identificador del node, mentre que el segon, defineix l'estil visual, que en aquest cas \u00e9s un rectangle.</li> <li>Per la seua banda, els casos d'\u00fas s'expressen amb la notaci\u00f3 <code>Cas((Cas))</code>, on <code>Cas</code> \u00e9s l'identificador i <code>((Cas))</code> defineix l'estil visual com una el\u00b7lipsi.</li> </ul> <p>Pel que fa a les connexions:</p> <ul> <li>Les fletxes <code>--&gt;</code> indiquen connexions cont\u00ednues entre nodes, i es mostraran com l\u00ednies cont\u00ednues.</li> <li>Les fletxes <code>-.-&gt;</code> i <code>-..-&gt;</code> es mostren com l\u00ednies discont\u00ednues i expressen connexions entre nodes i generalitzacions. A m\u00e9s, en les l\u00ednies discont\u00ednues, entre els punts, podem indicar etiquetes, per especificar el tipus de relaci\u00f3 (<code>-.include.-&gt;</code>)</li> </ul> <p>El reultat d'aquest diagrama ser\u00e0 el seg\u00fcent:</p> <pre><code>graph LR\n    Client[Client] --&gt; AfigProducte((Afig producte))\n    Client --&gt; RealitzaEncarrec((Realitza enc\u00e0rrec))\n    Encarregat -..-&gt;|Generalitzaci\u00f3| Client\n    RealitzaEncarrec -.include.-&gt; ValidaUsuari((Valida usuari))\n\n    Encarregat[Encarregat] --&gt; PrepararEncarrec((Preparar enc\u00e0rrec))\n        EnviarCorreu((Enviar correu)) -.extend.-&gt; PrepararEncarrec\n    EnviarSMS((Enviar SMS)) -.extend.-&gt; PrepararEncarrec</code></pre>"},{"location":"2.DiagramesCasosUs/#exemple-amb-plantuml","title":"Exemple amb PlantUML","text":"<p>Amb PlantUML el diagrama de casos d'\u00fas s'expressaria aix\u00ed:</p> <pre><code>``` plantuml\n@startuml\n:Client: --&gt; (Afig producte)\n:Client: --&gt; (Realitza enc\u00e0rrec)\n(Realitza enc\u00e0rrec) .&gt; (Valida usuari) : &lt;&lt;include&gt;&gt;\n\n:Encarregat: --&gt; (Preparar enc\u00e0rrec)\n(Enviar correu) ..&gt; (Preparar enc\u00e0rrec) : &lt;&lt;extend&gt;&gt;\n(Enviar SMS) ..&gt; (Preparar enc\u00e0rrec) : &lt;&lt;extend&gt;&gt;\n\n:Client:&lt;|--:Encarregat: \n@enduml\n```\n</code></pre> <p>Veiem els aspectes m\u00e9s rellevants de la sintaxi utilitzada aci:</p> <ul> <li><code>@startuml</code> i <code>@enduml</code>: indiquen l'inici i el final del diagrama.</li> <li>Definim els actors tancant l'identificador entre dos signes de dos punts, com <code>:Client:</code>.</li> <li>Els casos d'\u00fas es defineixen entre par\u00e8ntesis: <code>(Enviar SMS)</code></li> <li>Les relacions s'expressen amb fletxes, seguint el seg\u00fcent esquema:</li> <li></li> </ul> Fletxa Significat Exemple <code>--&gt;</code> Connexi\u00f3 directa o associaci\u00f3 entre un actor i un cas d'\u00fas. <code>:Client: --&gt; (Afig producte)</code> <code>.&gt;</code> Relaci\u00f3 <code>&lt;&lt;include&gt;&gt;</code> entre casos d'\u00fas. <code>(Realitza enc\u00e0rrec) .&gt; (Valida usuari) : &lt;&lt;include&gt;&gt;</code> <code>..&gt;</code> Relaci\u00f3 <code>&lt;&lt;extend&gt;&gt;</code> entre casos d'\u00fas. <code>(Enviar correu) ..&gt; (Preparar enc\u00e0rrec) : &lt;&lt;extend&gt;&gt;</code> <code>&lt;\\|--</code> Generalitzaci\u00f3 entre actors o casos d'\u00fas. <code>:Encarregat: &lt;\\|-- :Client:</code> <p>El resultat ser\u00e0 el seg\u00fcent:</p> <p></p> <p>A m\u00e9s, tamb\u00e9 podriem expressar el diagrama de la seg\u00fcent manera, definit primer els actors i casos d'\u00fas amb <code>actor</code> i <code>usecase</code>i utilitzar Alias (<code>as</code>), i posteriorment, definir les relacions fen \u00fas d'aquests \u00e0lias:</p> <pre><code>``` plantuml\n@startuml\nactor Client as C\nactor Encarregat as E\n\nusecase \"Afig Producte\" as AP\nusecase \"Realitzar Enc\u00e0rrec\" as RE\nusecase \"Valid usuari\" as VU\nusecase \"Preparar Enc\u00e0rrec\" as PE\nusecase \"Enviar correu\" as EC\nusecase \"Enviar SMS\" as ES\n\nC&lt;|--E \nC --&gt; AP\nC--&gt;RE\nRE .&gt; VU : &lt;&lt;include&gt;&gt;\nE --&gt; PE\nEC ..&gt; PE : &lt;&lt;extend&gt;&gt;\nES ..&gt; PE : &lt;&lt;extend&gt;&gt;\n@enduml\n```\n</code></pre> <p>Aix\u00f2 ens permet, a m\u00e9s, definir agrupacions d'actors o casos d'\u00fas, per exemple:</p> <pre><code>``` plantuml\n@startuml\nleft to right direction\nactor Client as C\nactor Encarregat as E\n\npackage FuncionalitatClient {\n    usecase \"Afig Producte\" as AP\n    usecase \"Realitzar Enc\u00e0rrec\" as RE\n    usecase \"Valid usuari\" as VU\n}\n\npackage FuncionalitatEncarregat{\n    usecase \"Preparar Enc\u00e0rrec\" as PE\n    usecase \"Enviar correu\" as EC\n    usecase \"Enviar SMS\" as ES\n}\n\nC&lt;|--E \nC --&gt; AP\nC--&gt;RE\nRE .&gt; VU : &lt;&lt;include&gt;&gt;\nE --&gt; PE\nEC ..&gt; PE : &lt;&lt;extend&gt;&gt;\nES ..&gt; PE : &lt;&lt;extend&gt;&gt;\n@enduml\n```\n</code></pre> <p>Com veiem, hem fet \u00fas de <code>package {...}</code> per agrupar casos d'\u00fas, i distingir la funcionalitat del client i la de l'encarregat en paquets diferents.</p> <p>A m\u00e9s, tamb\u00e9 hem fet \u00fas de la directiva <code>left to right direction</code>, que intenta dibuixar els diferents elements d'esquerra a dreta.</p> <p>El resultat \u00e9s aquest:</p> <p></p> <p>M\u00e9s informaci\u00f3...</p> <ul> <li>Al lloc web de DiagramasUML podeu trobar una guia per tal d'identificar possibles actors i casos d'\u00fas d'un sistema: https://diagramasuml.com/identificar-actores-y-casos-de-uso/.</li> <li>La documentaci\u00f3 oficial de PlantUML ens ofereix informaci\u00f3 molt m\u00e9s detallada i completa sobre la creaci\u00f3 de diagrames de casos d'\u00fas.</li> </ul>"},{"location":"2.DiagramesCasosUs/#descripcio-dels-requeriments-funcionals-i-no-funcionals","title":"Descripci\u00f3 dels requeriments funcionals i no funcionals","text":"<p>Quan definim els casos d'\u00fas, \u00e9s habitual descriure cada cas d'\u00fas com una seq\u00fc\u00e8ncia de passos que cal fer per completar-lo, i les possibles excepcions que poden haver.</p> <p>Per a cada cas d'\u00fas, tindrem un document, en forma de taula on es plasmen els diferents requeriments d'aquest. Aquests requeriments podran ser funcionals i no funcionals. </p> <p>Requisits funcionals i no funcionals</p> <p>Els requisits funcionals descriuen les accions o funcions que el sistema ha de ser capa\u00e7 de realitzar per satisfer les necessitats dels usuaris, com afegir productes al carret o enviar notificacions. Els requisits no funcionals fan refer\u00e8ncia a les especificacions de qualitat o limitacions que afecten el rendiment, la seguretat, la usabilitat o altres aspectes operatius del sistema, com la velocitat de resposta o el nivell de seguretat requerit. Per exemple, podr\u00eda ser que les transaccions i les comunicacions de xarxa es realitzaren de forma segura.</p> <p>A m\u00e9s dels requeriments, en la descripci\u00f3 dels casos d'\u00fas podem tindre la seg\u00fcent informaci\u00f3:</p> <ul> <li>Identificador i nom descriptiu</li> <li>Descripci\u00f3 del cas d'\u00fas</li> <li>Actors implicats</li> <li>Precondicions: Expressem en llenguatge natural les condicions necess\u00e0ries per a que es puga realitzar el cas d'\u00fas.</li> <li>Seq\u00fc\u00e8ncia normal de les interaccions del cas d'\u00fas. En cada pas, l'actor o el sistema realitzar\u00e0 una o m\u00e9s accions, o es realitzar\u00e0 altre cas d'\u00fas.</li> <li>Postcondici\u00f3: Expressem en llenguatge natural les condicions que s'han de complir despr\u00e9s de finalitzar el cas d'\u00fas de forma normal.</li> <li>Excepcions: Especifica el comportament del sistema en cas que es produ\u00efsca una situaci\u00f3 excepcional en algun pas.</li> </ul>"},{"location":"2.DiagramesCasosUs/#exemple","title":"Exemple","text":"<ul> <li>Cas d'\u00fas: RF01</li> <li>Nom: Realitza enc\u00e0rrec</li> <li>Actors: Usuari</li> <li>Descripci\u00f3:     L'usuari finalitza l'enc\u00e0rrec per iniciar el seu proc\u00e9s de preparaci\u00f3</li> <li>Precondicions:     S'ha de tractar d'un usuari del sistema, i el carret ha de tindre algun article</li> <li>Seq\u00fc\u00e8ncia normal:</li> <li>El sistema comprova que el carret continga articles</li> <li>Es valida l'usuari a trav\u00e9s del cas d'\u00fas corresponent</li> <li>S'emmagatzema l'enc\u00e0rrec a la base de dades.</li> <li>Postcondicions     S'ha generat un nou registre en la base de dades amb l'enc\u00e0rrec</li> <li>Excepcions:<ul> <li>1.1. Si el carret est\u00e0 buit, es mostra un missatge d'error a l'usuari.</li> <li>2.1. Si la validaci\u00f3 no es correcta es mostra un missatge d'error i no es continua.</li> <li>3.1. Si es produeix algun error en l'emmagatzemament s'informa a l'usuari i es genera un registre d'error.</li> </ul> </li> <li>Requisits no funcionals:<ul> <li>Les connexions han de ser segures, utilitzant protocols com HTTPS.</li> <li>El temps de resposta del sistema per emmagatzemar l'enc\u00e0rrec no ha de superar els 2 segons en condicions normals.</li> <li>Els missatges d'error han de ser clars i comprensibles per a l'usuari final.</li> </ul> </li> </ul>"},{"location":"2.DiagramesCasosUs/#dibuixant-diagrames-de-casos-dus","title":"Dibuixant diagrames de casos d'\u00fas","text":"<p>A l'hora de dibuixar casos d'\u00fas seguirem un raonament guiat pels seg\u00fcents passos:</p> <ol> <li>Identificar fonts d'informaci\u00f3, preguntant-nos d'on prov\u00e9 la informaci\u00f3 que utilitzar\u00e0 el sistema.</li> <li>Identificar actors potencials, com els usuaris i serveis que utilitzaran el sistema,</li> <li>Identificar possibles casos d'\u00fas, preguntant-nos quins serveis utilitzaran els actors,</li> <li>Associar actors i casos d'\u00fas, de manera que determinem quins actors tindran acc\u00e9s a quines funcionalitats del sistema,</li> <li>Determinar a quin o qu\u00e8 representen els actors, </li> <li>Buscar m\u00e9s casos d'\u00fas,</li> <li>Documentar detalladament cada cas d'\u00fas,</li> <li>Determinar relacions entre els difernts casos d'\u00fas i identificar accions que es realitzen repetidament.</li> <li>Comprovar la vista general per a que tot estiga correcte.</li> </ol> <p>Recordeu que per optimitzar aquest proc\u00e9s cal comprendre b\u00e9 el negoci i el sistema, i sovint haurem de fer part\u00edceps en l'elaboraci\u00f3 dels casos als clients, experts o consultors del negoci.</p>"},{"location":"2.DiagramesCasosUs/#exercicis","title":"Exercicis","text":"<p>A continuaci\u00f3 se us proposen un parell d'especificacions textuals, que podriem haver extret d'entrevistes o correus amb un posible client. </p> <p>A partir d'aquestes especificacions, haureu de generar el diagrama de casos d'\u00fas, seguint els pasos indicats anteriorment i com documentar aquests. Concretament, per a cada cas d'\u00fas es demana:</p> <ul> <li>Identificar actors principals i secundaris (usuaris finals, administradors, sistemes externs...).</li> <li>identificar els casos d'\u00fas</li> <li>Dissenyar els diagrames de casos d\u2019\u00fas per a cada especificaci\u00f3 (al menys un disseny amb Umbrello i altre amb PlantUML)</li> <li>Establir relacions com &lt;&lt; include &gt;&gt; i &lt;&lt; extend &gt;&gt; on siga necessari.</li> <li>Especificar els requeriments funcionals i no funcionals en taules associades als casos d'\u00fas.</li> </ul> <p>Especificaci\u00f3 1: Gesti\u00f3 d'una biblioteca digital</p> <p>Voldr\u00edem una aplicaci\u00f3 que permeta als usuaris buscar i demanar llibres en format digital o f\u00edsic. Els administradors del sistema haurien de poder gestionar el cat\u00e0leg, afegint o eliminant llibres, i gestionar tamb\u00e9 les sol\u00b7licituds de pr\u00e9stec. Els usuaris que s'hagen registrat poden veure l'historial de pr\u00e9stecs i descarregar llibres digitals. Les connexions amb el sistema han de ser segures, i el temps de resposta ha de ser r\u00e0pid, ja que els usuaris no tenen molta paci\u00e8ncia.</p> <p>Especificaci\u00f3 2: Sistema de reserva d'entrades per a esdeveniments</p> <p>Necessitem una plataforma en l\u00ednia per a la compra i reserva d'entrades per a esdeveniments culturals i esportius. Els usuaris registrats han de poder veure els esdeveniments disponibles, reservar entrades i veure les reserves al seu perfil. Els organitzadors d'esdeveniments han de poder publicar nous esdeveniments, actualitzar-ne els detalls i consultar estad\u00edstiques de vendes. A m\u00e9s, volem que el sistema notifique als usuaris per correu electr\u00f2nic quan un esdeveniment canvie de data o de localitzaci\u00f3.</p> <p>Especificaci\u00f3 3: Aplicaci\u00f3 de gesti\u00f3 de comandes en un restaurant</p> <p>Estem buscant una aplicaci\u00f3 que permeta als cambrers gestionar les comandes de les taules. Cada cambrer ha de poder assignar una comanda a una taula, afegir o eliminar plats, i finalitzar la comanda per enviar-la a la cuina. A la cuina, el sistema ha de mostrar les comandes pendents i permetre marcar-les com a preparades. Tamb\u00e9 volem que l\u2019aplicaci\u00f3 genere autom\u00e0ticament la factura per a cada taula i permeta als cambrers cobrar. \u00c9s important que l'aplicaci\u00f3 funcione b\u00e9 en dispositius m\u00f2bils.</p>"},{"location":"3.DiagramaClasses/","title":"3. Diagrama de classes","text":""},{"location":"3.DiagramaClasses/#diagrames-estructurals-i-el-diagrama-de-classes","title":"Diagrames estructurals i el diagrama de classes","text":"<p>Els diagrames estructurals o d'estructura s\u00f3n aquells que representen l'estructura est\u00e0tica dels objectes del sistema. Entre ells, el diagrama de classes \u00e9s el m\u00e9s conegut i utilitzat.</p> <p>El diagrama de classes \u00e9s un diagrama purament orientat al model de programaci\u00f3 orientat a objectes, ja que defineix les classes que s'utilitzaran i la manera en qu\u00e8 es relacionen entre elles. Com veurem, s'assembla molt al diagrama Entitat-Relaci\u00f3 (E/R), amb la difer\u00e8ncia que el diagrama de classes tamb\u00e9 representa la funcionalitat que ofereixen les classes. Ambd\u00f3s s\u00f3n models de dades l\u00f2gics d'un sistema.</p>"},{"location":"3.DiagramaClasses/#elements-dun-diagrama-de-classes","title":"Elements d'un diagrama de classes","text":"<p>El diagrama est\u00e0 format principalment per classes i les relacions entre elles, aix\u00ed com per interf\u00edcies. Veiem cadascuna d'elles.</p> <p>Conceptes sobre POO</p> <p>Abans d'endinsar-nos en el disseny i la creaci\u00f3 de diagrames de classes, anem a fer una introducci\u00f3 molt breu als diferents conceptes que tractarem.</p> <ul> <li>Objectes</li> <li>Un objecte \u00e9s una entitat amb certes propietats o atributs, els valors de les quals detrminen el seu estat, i determinat comportament, determinat per una s\u00e8rie de funcions que coneixem com m\u00e8todes.</li> <li>Un objecte, a m\u00e9s, t\u00e9 un nom pel qual s'identifica.</li> <li> <p>A m\u00e9s, cada objecte t\u00e9 una identitat \u00fanica, la qual permet diferenciar-lo d'altres objectes, encara que tinguen els mateixos valors (estat) als atributs.</p> </li> <li> <p>Classes</p> </li> <li>Una classe \u00e9s una abstracci\u00f3 d'un conjunt d'objectes, i un objecte ha de pert\u00e0nyer neccess\u00e0riament a alguna classe. Quan definim una classe hem de definir els atributs i m\u00e8todes que posse\u00efran els objectes.d'aquesta.</li> <li>Diem que un objecte \u00e9s una inst\u00e0ncia d'una classe.  </li> </ul>"},{"location":"3.DiagramaClasses/#representacio-de-classes","title":"Representaci\u00f3 de Classes","text":"<p>Les classes s\u00f3n l'element principal del diagrama i representen, com el seu nom indica, una classe dins del paradigma d'orientaci\u00f3 a objectes. Normalment s'utilitzen per a representar conceptes o entitats del negoci.</p> <p>Una classe defineix un grup d'objectes que comparteixen caracter\u00edstiques comunes. La manera m\u00e9s r\u00e0pida per a trobar classes sobre un enunciat o en general, sobre un tema concret \u00e9s buscar els substantius que apareixen en aquest. Per exemple: Persona, Missatge, Producte, etc.</p> <p>Una classe es compon de tres elements o seccions principals:</p> <ul> <li>El nom de la classe,</li> <li>Els atributs o propietats, que s\u00f3n variables associades a la classe i representen la part est\u00e0tica d'aquesta,</li> <li>Els m\u00e8todes, que s\u00f3n funcions associades a la classe, i representen la seua part din\u00e0mica.</li> </ul> <p>La representaci\u00f3 d'una classe \u00e9s una caixa dividida en tres zones, de la seg\u00fcent manera:</p> <pre><code>classDiagram\n    class Classe  {\n        +propietat1: Tipus\n        -propietat2: Tipus\n        #propietat3: Tipus\n\n        +metode1() Tipus\n        +metode2() Tipus\n    }</code></pre> <ul> <li>A la part superior s'indica el nom de la classe. Si es tracta d'una classe abstracta (\u00e9s a dir, no es pot instanciar directament, sin\u00f3 que serveix per definir altres classes), aquest nom s'indica en cursiva.</li> <li>La part central cont\u00e9 els atributs de la classe, un per l\u00ednia i amb els seg\u00fcents formats:</li> </ul> <pre><code>visibilitat nom_atribut : tipus = valorInicial { propietats }\n</code></pre> <pre><code>visibilitat nom_atribut : tipus\n</code></pre> <ul> <li>La zona inferior, finalment, inclou els m\u00e8todes de la classe, i s'expressen de forma semblant:</li> </ul> <pre><code>visibilitat nom_m\u00e8tode { *par\u00e0metres } : TipusRetorn { propietats }\n</code></pre> <pre><code>visibilitat nom_m\u00e8tode: TipusRetorn\n</code></pre> <p>Els atributs i m\u00e8todes tenen un tipus de dada (el tipus de dada de l'atribut, i el tipus de dada que retorna, en cas dels m\u00e8todes), aix\u00ed com una visibilitat o nivell d'acc\u00e9s, que determina qui pot o no accedir a ells.</p> <p>Sobre la visibilitat o el nivell d'acc\u00e9s a atributs i m\u00e8todes</p> <p>La visibilitat de propietats o m\u00e8todes ens ajuda a protegir i encapsular aquests, de manera que puguem decidir qui accedeix o no a aquestes. La visibilitat pot ser:</p> <ul> <li>public: L'atribut o m\u00e8tode \u00e9s accessible des de qualsevol lloc de l'aplicaci\u00f3.</li> <li>privat: L'atribut o m\u00e8tode nom\u00e9s \u00e9s accessible dins la mateixa classe.</li> <li>protegit: L'atribut o m\u00e8tode nom\u00e9s \u00e9s accessible dins la mateixa classe o les seues classes derivades.</li> </ul> <p>Habitualment, per tal d'aprofitar els beneficis de l'encapsulament i a\u00efllament de codi que proporciona la programaci\u00f3 orientada a objectes, els atributs es solen declarar com a privats, i nom\u00e9s en cas que es permeta l'acc\u00e9s a ells des de fora, es far\u00e0 a trav\u00e9s de m\u00e8todes p\u00fablics. Aquests m\u00e8todes es coneixen com setters (estableixen el valor d'un atribut) i getters (consulten el valor d'un atribut) o m\u00e8todes accessors.</p> <p>Els m\u00e8todes serviran per comunicar-nos amb els objectes i interactuar amb ells, a trav\u00e9s de missatges, que no \u00e9s m\u00e9s que la invocaci\u00f3 als seus m\u00e8todes.</p> <p>Als diagrames UML, expressem la visibilitat amb:</p> <ul> <li>(+): Per definir una propietat o m\u00e8tode com a p\u00fablica</li> <li>(-): Per definir una propietat o m\u00e8tode com a privada</li> <li>(#): Per definir una propietat o m\u00e8tode com a protegida</li> </ul> <p>Depend\u00e8ncia del llenguatge en la visibilitat i orientaci\u00f3 a objectes</p> <p>Els conceptes de public, private i protected s\u00f3n caracter\u00edstics de molts llenguatges orientats a objectes, com ara Java, i estan directament suportats per aquests llenguatges. Per exemple, Java permet declarar expl\u00edcitament la visibilitat dels atributs i m\u00e8todes d'una classe i proporciona mecanismes com els setters i getters per a implementar l'encapsulament. </p> <p>Altres llenguatges no implementen aquestes caracter\u00edstiques directament, per\u00f2 ofereixen altres mecanismes semblants. Al cas de Javascript per exemple, des de la versi\u00f3 ES11 (de 2019), podem fer \u00fas de <code>#</code> mer marcar atributs i m\u00e8todes privats.</p>"},{"location":"3.DiagramaClasses/#com-expressar-una-classe-en-plantuml-i-mermaid","title":"Com expressar una classe en PlantUML i Mermaid**:","text":"<p>La sintaxi per expressar classes en PlantUML \u00e9s la seg\u00fcent:</p> <pre><code>``` plantuml\n@startuml\nclass nomClasse {\n  -propietat_privada : tipus\n  #propietat_protegida : tipus\n  +metode_public() : tipus\n}\n@enduml\n```\n</code></pre> <p>Que ens genera el seg\u00fcent diagrama:</p> <p></p> <p>Observeu com es marquen amb un quadre roig els components privats, amb un romb groc les protegits, i amb un cercle verd els p\u00fablics.</p> <p>Per la seua banda, amb Mermaid, ho expressariem aix\u00ed:</p> <pre><code>```mermaid\nclassDiagram\n    class nomClasse {\n        -propietat_privada : tipus\n        #propietat_protegida : tipus\n        +metode_public() : tipus\n    }\n```\n</code></pre> <p>Que queda represenat aix\u00ed:</p> <pre><code>classDiagram\n    class nomClasse {\n        -propietat_privada : tipus\n        #propietat_protegida : tipus\n        +metode_public() : tipus\n    }</code></pre> <p>Veiem un exemple que podria representar un objecte tipus Nau en un videojoc:</p> <p></p> <p>Com veiem, es tracta d'una classe <code>Nau</code>, amb dos atributs privats: <code>posicioX</code> i <code>posicioY</code>. Per tal d'accedir a ells, es disposa dels m\u00e8todes <code>getPosicioX()</code> i <code>getPosicioY()</code>. A m\u00e9s, la classe defineix el m\u00e8tode <code>dispara()</code>.</p>"},{"location":"3.DiagramaClasses/#propietats-i-metodes-estatics","title":"Propietats i m\u00e8todes est\u00e0tics","text":"<p>Un atribut o m\u00e8tode est\u00e0tic \u00e9s aquell que ressideix en la classe, i no ens els objectes que s'instancien d'ella.</p> <p>En UML ho remarquem subratllant l'atribut o m\u00e8tode en q\u00fcesti\u00f3.</p> <p></p> <pre><code>classDiagram\n    class Classe {\n        propitat_estatica Tipus$\n    }</code></pre>"},{"location":"3.DiagramaClasses/#classes-en-accio-en-java-i-javascript","title":"Classes en acci\u00f3 en Java i Javascript","text":""},{"location":"3.DiagramaClasses/#java","title":"Java","text":"<p>La traducci\u00f3 a Java de la classe Nau anterior seria literal, incloent els atributs i m\u00e8todes corresponents, a m\u00e9s del m\u00e8tode constructor:</p> <pre><code>public class Nau {\n\n  /* Atributs */\n  private int posicioX;\n  private int posicioY;\n\n  /* Constructor */\n  public Nau () { };\n\n  /* M\u00e8todes d'acc\u00e9s */\n\n  public void setPosicioX (int valor) {\n    posicioX = valor;\n  }\n\n  public int getPosicioX () {\n    return posicioX;\n  }\n\n  public void setPosicioY (int valor) {\n    posicioY = valor;\n  }\n\n  public int getPosicioY () {\n    return posicioY;\n  }\n\n  /* Altres m\u00e8todes */\n  public void dispara() {\n    ...\n  }\n}\n</code></pre> <p>Instanciaci\u00f3</p> <p>La instanciaci\u00f3 \u00e9s el proc\u00e9s pel qual creem un nou objecte a partir d'una classe. Per a aix\u00f2 fem \u00fas de l'operador <code>new</code>:</p> <pre><code>Nau AlaX=new Nau();\nNau TieFighter=new Nau();\n</code></pre> <p>Quan fem \u00fas de <code>new</code> per obtenir una inst\u00e0ncia d'una classe (\u00e9s a dir, per crear un objecte), s'executa un m\u00e8tode especial de la classe, anomenat m\u00e8tode constructor, que s'encarrega generalment d'inicialitar l'objecte. Tota classe hauria de tindre, com a m\u00ednim, un constructor (aquest m\u00e8tode sol ometre's als diagrames UML per ser obvi).</p> <p>En Java, el m\u00e8tode constructor t\u00e9 el mateix nom que la classe, i pot ser un m\u00e8tode sobrecarregat. Aix\u00f2 significa que podem tindre definit el m\u00e8tode diverses vegades, sempre que tinga una llista d'arguments diferent. </p> <p>Quan una classe no requereix de cap inicialitzaci\u00f3 per instanciar-se, com \u00e9s el cas anterior, el constructor pot ometre's, de manara que Java afig un constructor per defecte.</p> <p>Als diagrames UML, no sol indicar-se el constructor, ja que assumim que tot objecte posseeix un m\u00e8tode constructor. Ara b\u00e9, en cas que volguem inicialitzar els objectes d'alguna manera especial i sobrecarregar el constructor, es podrien incloure aquests constructors.</p> <p>En cas que volguem afegir m\u00e9s constructors sobrecarregats, per\u00f2 tamb\u00e9 volguem proporcionar un constructor sense arguments, caldr\u00e0 indicar-los tots de manera expl\u00edcita. A l'exemple anterior, podriem haver definit els constructors com a:</p> <pre><code>public class Nau {\n  ...\n\n  /* Constructor buit. \n     Necessari si volem instanciar sense proporcionar arguments */\n  public Nau () { };\n\n  /* Constructor sobrecarregat \n     Crea una nau amb valors inicials per a la posici\u00f3\n  */\n  public Nau (int x, int y) {\n    this.posicioX=x;\n    this.posicioY=y;\n   };\n   ...\n}\n</code></pre> <p>Questi\u00f3...</p> <p>Si definim el seg\u00fcent:</p> <pre><code>Nau nau_1=new Nau(10,10);\nNau nau_2=new Nau(10,10);\n</code></pre> <p>Estem definint dues vegades el mateix objecte?</p> <p>La resposta \u00e9s que NO. Cada objecte t\u00e9 una identitat pr\u00f2pia, i s'emmagatzema en una variable diferent. \u00c9s m\u00e9s, cada objecte ocupa una direcci\u00f3 de mem\u00f2ria diferent.</p> <p>Si compar\u00e0rem els dos objectes <code>nau_1==nau_2</code>, obtindriem Fals com a resposta.</p> <p>Moltes classes solen implementar un m\u00e8tode <code>equals</code> per comparar un objecte amb altre, de manera que internament, comparen el valor dels diferents atributs i determinen si s\u00f3n els mateixos o no.</p> <p>En Java, les classes tamb\u00e9 permeten un modificador d'acc\u00e9s. Aquest pot ser:</p> <ul> <li>public: Classe p\u00fablica, accessible des de qualsevol altra classe. Nom\u00e9s pot haver una classe p\u00fablica en cada fitxer font (ext .java), i ha de tindre el mateix nom que el fitxer. Si no indiquem res, la classe nom\u00e9s podr\u00e0 ser accedida des del mateix paquet (package).</li> <li>abstract / final: S'utilitzen quan fem \u00fas de l'her\u00e8ncia:<ul> <li>abstract: La classe no permet la instanaciaci\u00f3 d'objectes, sin\u00f2 la definici\u00f3 d'altres classes que implementen m\u00e8todes que aquesta defineix com a abstractes.</li> <li>final: Classe que implementa els m\u00e8todes abstractes, i de la que no es podran crear subclasses.</li> </ul> </li> </ul>"},{"location":"3.DiagramaClasses/#javascript","title":"Javascript","text":"<p>La traducci\u00f3 a Javascript de la classe Nau seria aix\u00ed:</p> <pre><code>class Nau {\n// Atributs privats\n  #posicioX; \n  #posicioY;\n\n  constructor(x = 0, y = 0) {\n    this.#posicioX = x;\n    this.#posicioY = y;\n  }\n\n  // Getters\n  get posicioX() {\n    return this.#posicioX;\n  }\n\n  get posicioY() {\n    return this.#posicioY;\n  }\n\n  // Setters\n  set posicioX(valor) {\n    this.#posicioX = valor;\n  }\n\n  set posicioY(valor) {\n    this.#posicioY = valor;\n  }\n\n  dispara() {\n\n  }\n}\n</code></pre> <p>I podr\u00edem instanciar aquesta, per exemple amb:</p> <pre><code>const nau = new Nau(10, 10);\n</code></pre> <p>En primer lloc, fixem-nos en la forma de declarar i accedir a les propietats <code>#posicioX</code> i <code>#posicioY</code>. Amb el s\u00edmbol <code>#</code> al davant estem indicant que es tracta de propietats privades, de manera ue nom\u00e9s poden ser accessibles des de dins de la classe.</p> <p>Observeu tamb\u00e9, que en aquest cas, els <code>getters</code> i <code>setters</code> s\u00f3n funcions que tenen al davant la paraula clau <code>get</code> o <code>set</code>. Aix\u00f2 ens permetr\u00e0 accedir a ells com si es tractara de propietats p\u00fabliques. \u00c9s a dir, que podem fer coses com:</p> <pre><code>console.log(nau.posicioX)\n</code></pre> <pre><code>nau.posicioY=15\nconsole.log(nau.posicioY)\n</code></pre> <p>I finalment, observeu que el constructor ara \u00e9s \u00fanic, i defineix valors per defecte per a les propietats. D'aquesta manera, si el constructor s'invoca sense arguments:</p> <pre><code>const nau3=new Nau()\n</code></pre> <p>El valor de les seues propietats ser\u00e0 l'indicat per defecte (0,0).</p> <p>Questi\u00f3</p> <p>Si definim aix\u00ed la nau:</p> <pre><code>class Nau {\n   // Atributs privats\n     #pos_x;\n     #pos_y;\n\n   constructor(x = 0, y = 0) {\n     this.#pos_X = x;\n     this.#pos_Y = y;\n   }\n\n   // Getters\n   get posicioX() {\n     return this.#pos_X;\n   }\n\n   get posicioY() {\n     return this.#pos_Y;\n   }\n\n   // Setters\n   set posicioX(valor) {\n     this.#pos_X = valor;\n   }\n\n   set posicioY(valor) {\n     this.#pos_Y = valor;\n   }\n }\n</code></pre> <p>Podrem fer, per exemple <code>console.log(posicioX)</code>? I <code>posicioY=20</code>?</p> <p>Generaci\u00f3 autom\u00e0tica de codi</p> <p>Cal tindre en compte que quan utilitzem eines CASE que ens ajuden a crear el codi a partir dels diagrames, \u00e9s possible que ens generen autom\u00e0ticament els m\u00e8todes accessors als atributs, de manera que no siga necessari incloure'ls al diagrama.</p> <p>A tindre en compte...</p> <p>Com hem vist, hem de tindre en compte que la sintaxi, tant per definir les classes com els m\u00e8todes accessors i altres caracter\u00edstiques dependr\u00e0 en gran mesura del llenguatge de programaci\u00f3 que escollim, i fins i tot, potser hi haja alguns aspectes que podem representar als diagrames UML que no es puguen veure reflexats en una implementaci\u00f3.</p>"},{"location":"3.DiagramaClasses/#representacio-de-relacions","title":"Representaci\u00f3 de Relacions","text":"<p>Les diferents classes que conformen una aplicaci\u00f3 interaccionen entre elles, a trav\u00e9s de diferents tipus de relacions. Generalment, les relacions seran entre dos o m\u00e9s classes, tot i que de vegades, una classe pot establir relacions amb ella mateixa (depend\u00e8ncia reflexiva).</p> <p>Per tal de representar una relaci\u00f3 entre classes en un diagrama de classes fem \u00fas d'una l\u00ednia que les uneix. Aquesta l\u00ednia ser\u00e0 diferent segons el tipus de relaci\u00f3.</p> <p>Les relacions en el diagrama de classes tenen diverses propietats, que podrem representar m\u00e9s o menys segons el nivell de detall que volguem aportar. Aquestes propietats de les relacions s\u00f3n:</p> <ul> <li>Multiplicitat: Indica el nombre d'elements que participen en la relaci\u00f3. Pot ser un n\u00famero, un rang.. Si es tracta d'un n\u00famero qualsevol, podem utilitzar <code>*</code>o <code>n</code>.</li> <li>Nom de l'associaci\u00f3, que ens ajuda a entendre la relaci\u00f3 entre les classes.</li> </ul>"},{"location":"3.DiagramaClasses/#tipus-de-relacions","title":"Tipus de relacions","text":"<p>Les relacions, com hem dit poden ser de diferents tipus. En un diagrama de classes, podem trobar-nos els seg\u00fcents tipus de relacions:</p> <ul> <li>Associaci\u00f3.</li> <li>Agregaci\u00f3.</li> <li>Composici\u00f3.</li> <li>Depend\u00e8ncia.</li> <li>Her\u00e8ncia.</li> </ul> <p>Vegem cadascun d'aquests tipus de relacions.</p>"},{"location":"3.DiagramaClasses/#associacio","title":"Associaci\u00f3","text":"<p>\u00c9s la relaci\u00f3 m\u00e9s comuna i s'utilitza per a representar depend\u00e8ncia sem\u00e0ntica, sense cap implicaci\u00f3 de propietat. Es representa amb una simple l\u00ednia cont\u00ednua que uneix les classes que estan incloses en l'associaci\u00f3.</p> <p>Veiem un exemple:</p> <p></p> <p>En aquest exemple, tenim definides dues classes: <code>Nau</code> i <code>Pilot</code>. La relaci\u00f3 entre elles \u00e9s que un <code>Pilot</code>, <code>Pilota</code> una <code>Nau</code>. Com veiem, la relaci\u00f3 t\u00e9 una multiplicitat 1:1, \u00e9s a dir, en un moment donat, un pilot est\u00e0 pilotant una nau, i una nau \u00e9s pilotada per un pilot.</p> <p>Tal i com l'hem expressada, es tracta d'una relaci\u00f3 bidireccional. Aix\u00f2 vol dir que des de <code>Nau</code>, podem navegar a <code>Pilot</code>, i a l'inrev\u00e8s. En altres paraules, donada una nau podem saber qui la pilota, i donat un pilot podem saber quina nau pilota.</p> <p>Aquestes relacions d'associaci\u00f3, tamb\u00e9 admeten associacions unidirecconals, que restringeixen la direcci\u00f3 de navegaci\u00f3. Per expressar aix\u00f2, farem \u00fas d'una fletxa que indicar\u00e0 el sentit d'aquesta associaci\u00f3:</p> <p></p>"},{"location":"3.DiagramaClasses/#representacio-dassociacions-en-plantuml-i-mermaid","title":"Representaci\u00f3 d'associacions en PlantUML i Mermaid","text":"<ul> <li>PlantUML:</li> </ul> <pre><code>``` plantuml\n  @startuml\n  class Nau {\n    -posicioX : int\n    -posicioY : int\n    +dispara() : void\n  }\n\n  class Pilot {\n    -nom : String\n  }\n\n  Pilot --&gt; Nau : pilota\n  @enduml\n  ```\n</code></pre> <p>I el resultat:</p> <p></p> <ul> <li>Mermaid:</li> </ul> <pre><code>```mermaid\n  classDiagram\n      class Nau {\n          - posicioX: int\n          - posicioY: int\n          + dispara(): void\n      }\n\n      class Pilot {\n          - nom: String\n      }\n\n      Pilot --&gt; Nau : pilota\n```\n</code></pre> <pre><code>  classDiagram\n      class Nau {\n          - posicioX: int\n          - posicioY: int\n          + dispara(): void\n      }\n\n      class Pilot {\n          - nom: String\n      }\n\n      Pilot --&gt; Nau : pilota</code></pre>"},{"location":"3.DiagramaClasses/#aspectes-sobre-la-implementacio","title":"Aspectes sobre la implementaci\u00f3","text":"<p>Com hem comentat, les relacions s\u00f3n un concepte sem\u00e0ntic, i sovint no tenen una equival\u00e8ncia exacta quan ho passem a un llenguatge de programaci\u00f3. Per exemple... com expressar\u00edeu les dues relacions anteriors amb Java? El mecanisme que tenim a Java (o altres llenguatges de programaci\u00f3) per relacionar classes \u00e9s utilitzar les classes com a tipus de dades, i definir objectes d'aquest tipus dins d'altres. Com veurem, totes les relacions, quan les passem a Java es basaran en aquest mecanisme. Aix\u00ed doncs, per tal d'establir la relaci\u00f3 direccional anterior amb Java, inclouriem un objecte de tipus Pilot dins la definici\u00f3 de Nau:</p> <pre><code>/* Classe Pilot */\n\npublic class pilot {\n\n  // Atributs\n  private String Nom;\n\n  // Constructor\n  public pilot () { };\n\n  // M\u00e8todes accessors\n  public void setNom (String newVar) {\n    Nom = newVar;\n  }\n\n  public String getNom () {\n    return Nom;\n  }\n\n}\n</code></pre> <pre><code>/* Classe Nau */\npublic class nau {\n\n  // Atributs\n  private int posicioX;\n  private int posicioY;  \n  private pilot pilotActual;\n\n  // Constructor\n  public nau () { };\n\n  // M\u00e8todes accessors\n  public void setPosicioX (int newVar) {\n    posicioX = newVar;\n  }\n\n  public int getPosicioX () {\n    return posicioX;\n  }\n\n  public void setPosicioY (int newVar) {\n    posicioY = newVar;\n  }\n\n  public int getPosicioY () {\n    return posicioY;\n  }\n\n  public void setPilot (int newPilot) {\n    pilotActual = newPilot;\n  }\n\n  public pilot getPilot () {\n    return pilotActual;\n  }\n\n  // Altres m\u00e8todes\n  public void dispara()\n  {\n  }\n</code></pre> <p>En cas que volgu\u00e8rem que l'associaci\u00f3 fora bidireccional, hauriem d'incloure tamb\u00e9 un objecte de tipus Nau dins de Pilot. L'inconvenient d'aix\u00f2 \u00e9s que caldria program\u00e0ticament estar pedent de quan caviem aquesta associaci\u00f3 que es modifiquen els dos objectes relacionats. En estos casos, el m\u00e9s pr\u00e0ctic ser\u00e0 determinar quin ser\u00e0 el sentit normal de les relacions, i fer \u00fas d'associacions direccionals incloent nom\u00e9s un objecte d'una classe dins l'altra. A l'exemple anterior, ens ser\u00e0 m\u00e9s \u00fatil con\u00e9ixer quin pilot est\u00e0 pilotant una nau en un moment donat, que no quina nau pilota un pilot en un moment donat.</p> <p>Associacions amb multiplicitat N</p> <p>Quan la multiplicitat de la relaci\u00f3 \u00e9s 1, hem vist que definim objectes d'un tipus dins d'altres. </p> <p>Ara b\u00e9, com ho farem quan la relaci\u00f3 t\u00e9 multiplicitat N?</p>"},{"location":"3.DiagramaClasses/#agregacio","title":"Agregaci\u00f3","text":"<p>Les relacions d'agregaci\u00f3 (\"t\u00e9 un\") indiquen quan un objecte (el conjunt) est\u00e0 format per alters objectes. \u00c9s a dir, una classe (el conjunt) est\u00e0 formada per altres classes (les parts), per\u00f2 aquestes poden existir independentment.</p> <p>Per exemple, al cas de la nau, una nau pot estar formada per un propulsor, una cabina i un can\u00f3:</p> <p></p> <p>Com veiem, la forma de representar a\u00e7\u00f2 en Java, ser\u00e0 incorporar com a atributs tres objectes de tipus Cabina, Propulsor i Can\u00f3 dins la classe Nau.</p> <p>Veiem com expressar aquesta relaci\u00f3 amb PlantUML i Mermaid:</p> <ul> <li>PlantUML: Fem \u00fas de la notaci\u00f3 <code>o--</code> per indicar que la classe de l'esquerra cont\u00e9 una inst\u00e0ncia de la classe de la dreta.</li> </ul> <pre><code>  ``` plantuml\n  @startuml\n  class Nau {\n    -propulsor : Propulsor\n    -cabina : Cabina\n    -cano : Cano\n  }\n\n  class Propulsor\n  class Cabina\n  class Cano\n\n  Nau o-- Propulsor\n  Nau o-- Cabina\n  Nau o-- Cano\n  @enduml\n  ```\n</code></pre> <p>Que te la seg\u00fcent representaci\u00f3:</p> <p></p> <p>Mermaid: fa \u00fas tamb\u00e9 de la seq\u00fc\u00e8ncia <code>o--</code> per indicar l'agregaci\u00f3:</p> <pre><code>```mermaid\n  classDiagram\n      class Nau {\n          - propulsor: Propulsor\n          - cabina: Cabina\n          - cano: Cano\n      }\n\n      class Propulsor\n      class Cabina\n      class Cano\n\n      Nau o-- Propulsor\n      Nau o-- Cabina\n      Nau o-- Cano\n```\n</code></pre> <p>Que es representa:</p> <pre><code>  classDiagram\n      class Nau {\n          - propulsor: Propulsor\n          - cabina: Cabina\n          - cano: Cano\n      }\n\n      class Propulsor\n      class Cabina\n      class Cano\n\n      Nau o-- Propulsor\n      Nau o-- Cabina\n      Nau o-- Cano</code></pre>"},{"location":"3.DiagramaClasses/#composicio","title":"Composici\u00f3","text":"<p>Es tracta d'un cas especial d'agregaci\u00f3, per\u00f2 amb un valor sem\u00e0ntic m\u00e9s fort, on els elements que en formen part, no tenen sentit sense l'objecte que componen: Quan l'element compost desapareix, totes les seues parts desapareixen, ja que no tenen sentit per s\u00ed mateixos. A difer\u00e8ncia tamb\u00e9 de l'agregaci\u00f3, en la composici\u00f3, els elements components no es poden compartir entre diversos elements, mentre que en l'agregaci\u00f3 el mateix objecte s\u00ed que pot estar compartit amb diversos elements.</p> <p>La seua representaci\u00f3 al diagrama de classes \u00e9s amb una l\u00ednia cont\u00ednua amb un romble ple en la classe que \u00e9s composta.</p> <p>Per exemple, una partida d'un videojoc en l\u00ednia ser\u00e0 la composici\u00f3 de diversos jugadors:</p> <p></p> <p>Aquest diagrama indica que una partida est\u00e0 composada per diversos jugadors. En aquest cas, una vegada es finalitza i es destrueix una partida, els jugadors de la partida deixen de tindre sentit. Fixeu-vos que la multiplicitat de Jugadors \u00e9s un a molts, el que vol dir que una partida tindr\u00e0 entre un i diversos jugadors.</p> <p>La difer\u00e8ncia entre agregaci\u00f3 i composici\u00f3 \u00e9s sem\u00e0ntica, i  la majoria de llenguatges de programaci\u00f3, com \u00e9s el cas de Java no diferencien entre elles.</p>"},{"location":"3.DiagramaClasses/#representacio-en-mermaid-i-plantuml","title":"Representaci\u00f3 en Mermaid i PlantUML","text":"<p>En PlantUML i Mermaid fem \u00fas de la seq\u00fc\u00e8ncia de caracters <code>*--</code> per tal d'expressar una composici\u00f3:</p> <p>PlantUML:</p> <pre><code>``` plantuml\n  @startuml\n  class Partida {\n    -jugadors : Jugador[]\n  }\n\n  class Jugador {\n    -nom : String\n  }\n\n  Partida *-- Jugador\n  @enduml\n  ```\n</code></pre> <p></p> <p>Mermaid:</p> <pre><code>```mermaid\n  classDiagram\n      class Partida {\n          - jugadors: Jugador[]\n      }\n\n      class Jugador {\n          - nom: String\n      }\n\n      Partida *-- Jugador\n  ```\n</code></pre> <pre><code>classDiagram\n    class Partida {\n        - jugadors: Jugador[]\n    }\n\n    class Jugador {\n        - nom: String\n    }\n\n    Partida *-- Jugador</code></pre> <p>!!!!note \"Composicions en Java\"     Podeu veure una implementaci\u00f3 d'aquest exemple en Java al document Composicions en Java</p>"},{"location":"3.DiagramaClasses/#dependencia","title":"Depend\u00e8ncia","text":"<p>La relaci\u00f3 de depend\u00e8ncia es d\u00f3na quan una classe requereix d'alguna funcionalitat d'altra classe. La seua representaci\u00f3 \u00e9s una fletxa discont\u00ednua, des de la classe que requereix la utilitat de l'altra fins la classe que la ofereix.</p> <p>Un exemple de depend\u00e8ncia podria ser el seg\u00efent:</p> <p>{</p> <p>Com veiem, aix\u00ed expressem que la classe Calculadora dep\u00e8n de la classe Primes, de la llibreria <code>org.apache.commons.math3.primes.Primes</code>.</p>"},{"location":"3.DiagramaClasses/#representacio-de-dependencia-en-plantuml-i-mermaid","title":"Representaci\u00f3 de depend\u00e8ncia en PlantUML i Mermaid","text":"<p>En PlantUML:</p> <pre><code>  ``` plantuml\n  @startuml\n  class Calculadora {\n    +calculaPrimes() : void\n  }\n\n  class Primes\n\n  Calculadora ..&gt; Primes : utilitza\n  @enduml\n  ```\n</code></pre> <p>Es representa com a:</p> <p></p> <p>I en mermaid:</p> <pre><code>```mermaid\n  classDiagram\n      class Calculadora {\n          + calculaPrimes(): void\n      }\n\n      class Primes\n\n      Calculadora ..&gt; Primes : utilitza\n  ```\n</code></pre> <p>Es representa:</p> <pre><code>classDiagram\n    class Calculadora {\n        + calculaPrimes(): void\n    }\n\n    class Primes\n\n    Calculadora ..&gt; Primes : utilitza</code></pre>"},{"location":"3.DiagramaClasses/#herencia","title":"Her\u00e8ncia","text":"<p>L'her\u00e8ncia \u00e9s un dels tipus de relaci\u00f3 m\u00e9s interessants i utilitzats en programaci\u00f3 orientada a objectes, i ens permet que una classe filla, herete atributs i m\u00e8todes d'una altra classe (classe pare o superclasse). La subclasse, a m\u00e9s, podr\u00e0 definir nous m\u00e8todes i atributs. S'utilitza en relacions \u00e9s un.</p> <p>Als diagrames de classes, per tal d'indicar una relaci\u00f3 d'her\u00e8ncia, es fa \u00fas d'una l\u00ednia amb un triangle a l'extrem on es troba la classe de la que s'hereta. Veiem-ho a seg\u00fcent exemple:</p> <p></p> <p>Com veiem, tant les classes <code>TieFighter</code> com <code>XWing</code> i <code>YWing</code> s\u00f3n una especialitzaci\u00f3 de la classe <code>Nau</code>, pel que hereten les seues propietats (<code>posicioX</code> i <code>posicioY</code>) aix\u00ed com els seus m\u00e8todes (<code>dispara()</code>). A m\u00e9s, cadascuna de les classes, defineix altres m\u00e8todes propis de la classe, com <code>ActivarCamuflatge()</code> en <code>TieFighter</code>, <code>Llan\u00e7arBomba()</code> en <code>XWing</code> i <code>BotarHiperespai</code> en <code>YWing</code>.</p> <p>Per tal d'expressar una relaci\u00f3 d'her\u00e8ncia en PlantUML farem:</p> <pre><code>``` plantuml\n@startuml\nclass Nau {\n  -posicioX : int\n  -posicioY : int\n  +dispara() : void\n}\n\nclass TieFighter {\n  +activarCamuflatge() : void\n}\n\nclass XWing {\n  +llan\u00e7arBomba() : void\n}\n\nclass YWing {\n  +botarHiperespai() : void\n}\n\nTieFighter --|&gt; Nau\nXWing --|&gt; Nau\nYWing --|&gt; Nau\n@enduml\n```\n</code></pre> <p></p> <p>Per la seua banda, en Mermaid la sintaxi \u00e9s pr\u00e0cticament id\u00e8ntica:</p> <pre><code>```mermaid\nclassDiagram\n    class Nau {\n        - posicioX: int\n        - posicioY: int\n        + dispara(): void\n    }\n\n    class TieFighter {\n        + activarCamuflatge(): void\n    }\n\n    class XWing {\n        + llan\u00e7arBomba(): void\n    }\n\n    class YWing {\n        + botarHiperespai(): void\n    }\n\n    TieFighter --|&gt; Nau\n    XWing --|&gt; Nau\n    YWing --|&gt; Nau\n\n```\n</code></pre> <p>I es representa:</p> <pre><code>classDiagram\n    class Nau {\n        - posicioX: int\n        - posicioY: int\n        + dispara(): void\n    }\n\n    class TieFighter {\n        + activarCamuflatge(): void\n    }\n\n    class XWing {\n        + llan\u00e7arBomba(): void\n    }\n\n    class YWing {\n        + botarHiperespai(): void\n    }\n\n    TieFighter --|&gt; Nau\n    XWing --|&gt; Nau\n    YWing --|&gt; Nau</code></pre>"},{"location":"3.DiagramaClasses/#implementacio-en-java","title":"Implementaci\u00f3 en Java","text":"<p>En Java, fem \u00fas de la paraula reservada <code>extends</code>per indicar que una classe deriva d'una altra. Veiem com quedaria l'exemple de dalt:</p> <pre><code>public class Nau {\n  private int posicioX;\n  private int posicioY;\n\n  /* Constructor */\n  public Nau () { };\n\n  /* M\u00e8todes d'acc\u00e9s */\n  public void setPosicioX (int newVar) {\n    posicioX = newVar;\n  }\n\n  public int getPosicioX () {\n    return posicioX;\n  }\n\n  public void setPosicioY (int newVar) {\n    posicioY = newVar;\n  }\n\n  public int getPosicioY () {\n    return posicioY;\n  }\n\n  /* Altres m\u00e8todes */\n  public void dispara()\n  {\n  }\n}\n</code></pre> <pre><code>class TieFigter extends Nau {\n\n    // Constructor\n    TieFigher(){\n        // Invoca al constructor del pare\n        super();\n    }\n\n    // M\u00e8todes nous\n    void ActivarCamuflatge(){\n        ...\n    }\n}\n</code></pre> <pre><code>class XWing extends Nau {\n\n    // Constructor\n    TieFigher(){\n        // Invoca al constructor del pare\n        super();\n    }\n\n    // M\u00e8todes nous\n    void Llan\u00e7arBomba(){\n        ...\n    }\n}\n</code></pre> <pre><code>class YWing extends Nau {\n\n    // Constructor\n    TieFigher(){\n        // Invoca al constructor del pare\n        super();\n    }\n\n    // M\u00e8todes nous\n    void BotarHiperespai(){\n        ...\n    }\n}\n</code></pre> <p>A\u00e7\u00f2 ens permet, per exemple, definir un objecte de tipus <code>XWing</code>:</p> <pre><code>XWing nauLuke=new XWing();\n</code></pre> <p>I utilitzar tant els m\u00e8todes de <code>Nau</code> com de <code>XWing</code>:</p> <pre><code>nauLuke.dispara();\nnauLuke.Llan\u00e7arBomba();\n</code></pre>"},{"location":"3.DiagramaClasses/#implementacio-en-javascript","title":"Implementaci\u00f3 en JavaScript","text":"<p>En JavaScript (ES6+), tamb\u00e9 podem establir relacions d'her\u00e8ncia utilitzant la paraula reservada <code>extends</code>. L'equivalent a l'exemple anterior en JavaScript seria el seg\u00fcent:</p> <pre><code>// Definici\u00f3 de la classe base Nau\nclass Nau {\n  #posicioX; // Atribut privat\n  #posicioY;\n\n  constructor(x = 0, y = 0) {\n    this.#posicioX = x;\n    this.#posicioY = y;\n  }\n\n  // Getters i Setters\n  get posicioX() {\n    return this.#posicioX;\n  }\n\n  set posicioX(valor) {\n    this.#posicioX = valor;\n  }\n\n  get posicioY() {\n    return this.#posicioY;\n  }\n\n  set posicioY(valor) {\n    this.#posicioY = valor;\n  }\n\n  dispara() {\n    console.log(\"Disparant!\");\n  }\n}\n\n// Definici\u00f3 de la classe TieFighter, que hereta de Nau\nclass TieFighter extends Nau {\n  constructor(x, y) {\n    super(x, y); // Invoca al constructor del pare\n  }\n\n  activarCamuflatge() {\n    console.log(\"Activant camuflatge!\");\n  }\n}\n\n// Definici\u00f3 de la classe XWing, que hereta de Nau\nclass XWing extends Nau {\n  constructor(x, y) {\n    super(x, y); // Invoca al constructor del pare\n  }\n\n  llan\u00e7arBomba() {\n    console.log(\"Llan\u00e7ant bomba!\");\n  }\n}\n\n// Definici\u00f3 de la classe YWing, que hereta de Nau\nclass YWing extends Nau {\n  constructor(x, y) {\n    super(x, y); // Invoca al constructor del pare\n  }\n\n  botarHiperespai() {\n    console.log(\"Botant a l'hiperespai!\");\n  }\n}\n\n// Exemple d'\u00fas\nconst nauLuke = new XWing(10, 20);\nconsole.log(nauLuke.posicioX); // Mostra 10\nnauLuke.dispara(); // \"Disparant!\"\nnauLuke.llan\u00e7arBomba(); // \"Llan\u00e7ant bomba!\"\n</code></pre>"},{"location":"3.DiagramaClasses/#classes-abstractes","title":"Classes abstractes","text":"<p>En principi, podrem instanciar objectes de les quatre classes. En cas que nom\u00e9s tinguera sentit definir naus dels tipus de les subclasses, podriem definir la classe <code>Nau</code> com a classe abstracta, indicant que aquesta classe nom\u00e9s serveix per definiar altres classes, per\u00f2 no per instanciar objectes.</p> <p>Per expressar aix\u00f2 en PlantUML fem \u00fas de la paraula <code>abstract</code> davant la classe:</p> <pre><code>![Diagrama UML](../diagrames/3.DiagramaClasses/diagram_853652654756110696.svg)\n</code></pre> <p>Que queda representat aix\u00ed:</p> <p></p> <p>Com veiem, en lloc d'una C davant la classe, apareix una A, indicant que \u00e9s abstracta.</p> <p>Per la seua banda, a Mermaid fem \u00fas de la paraula clau <code>&lt;&lt;abstract&gt;&gt;</code> dins la definic\u00f3 de la classe:</p> <pre><code>```mermaid\nclassDiagram\nclass Nau {\n&lt;&lt;abstract&gt;&gt;\n  -posicioX : int\n  -posicioY : int\n  +dispara() : void\n}\n\n```\n</code></pre> <p>Que es representa mostrant <code>abstract</code> davant la classe al diagrama corresponent:</p> <pre><code>classDiagram\nclass Nau {\n&lt;&lt;abstract&gt;&gt;\n  -posicioX : int\n  -posicioY : int\n  +dispara() : void\n}\n</code></pre> <p>Notes sobre el polimorfisme</p> <p>Un altre aspecte interessant que introdueix la programaci\u00f3 orientada a objectes \u00e9s el polimorfisme, que ens permet enviar missatges sint\u00e0cticament iguals a classes de diferent tipus. Per exemple, el m\u00e8tode <code>dispara()</code> es pot utilitzar en qualsevol objecte de la classe <code>nau</code> o de qualsevol de les classes derivades. A\u00e7\u00f2 ens permet, per exemple, en una partida, tindre una estructura de dades d'objectes gen\u00e8rics, de tipus nau, que emmagatzeme naus de qualsevol tipus.</p> <p>Per exemple, podriem definir un <code>ArrayList</code> d'objectes de tipus <code>Nau</code>:</p> <pre><code>ArrayList&lt;Nau&gt; flota=new ArratList&lt;Nau&gt;();\n</code></pre> <p>I afegir elements de qualsevol tipus derivat a dins:</p> <pre><code>XWing nauLuke=new XWing();\nYWing nauSnap=new YWing();\nTieFighter nauVader=new TieFighter();\n\nflota.add(nauLuke);\nflota.add(nauSnap);\nflota.add(nauVader);\n</code></pre> <p>Sobre l'herencia m\u00faltiple</p> <p>En un diagrama de classes ens podem trobar el cas que una classe siga una especialitzaci\u00f3 de dues classes ascendents. Per exemple:</p> <p></p> <p>En aquest exemple, la classe <code>Trident</code> \u00e9s una especialitzaci\u00f3 tant de <code>Nau</code> com de <code>VehicleAquatic</code>, pel que hereta les propietats i m\u00e8todes de les dos.</p> <p>L'her\u00e8ncia m\u00faltiple no est\u00e0 suportada en tots els llenguatges de programaci\u00f3. Al cas de Java i Javascript, per exemple, una classe nom\u00e9s pot tindre una classe ascendent. Aquesta limitaci\u00f3 del llenguatge es supleix mitjan\u00e7ant les interf\u00edcies.</p>"},{"location":"3.DiagramaClasses/#interficies","title":"Interf\u00edcies","text":"<p>Una interf\u00edcie \u00e9s una entitat que declara una s\u00e8rie d'atributs, m\u00e8todes i obligacions. \u00c9s una esp\u00e8cie de contracte on tota inst\u00e0ncia associada a una interf\u00edcie ha d'implementar els serveis que indica aquella interf\u00edcie.</p> <p>Com que \u00fanicament s\u00f3n declaracions, les interf\u00edcies no poden ser instanciades, \u00e9s a dir, no podem crear objectes a partir d'una interf\u00edcie.</p> <p>Les interf\u00edcies s'associen a classes. Aix\u00f2 vol dir que una classe compleix amb el contracte que indica la interf\u00edcie, \u00e9s a dir, inclou aquells m\u00e8todes i atributs que indica la interf\u00edcie.</p> <p>La seua representaci\u00f3 \u00e9s similar a les classes, per\u00f2 indicant a dalt la paraula <code>&lt;&lt;interface&gt;&gt;</code>:</p> <p></p> <p>En aquest exemple, una nau diem que implementa  la interf\u00edcie <code>Dibuixable</code>, que obliga a les classes que la implementen a disposar d'un m\u00e8tode Dibuixa(), per dibuixar la nau a la pantalla. En el cas de les interf\u00edcies, una classe s\u00ed que pot implementar diverses interf\u00edcies, suplint aix\u00ed la limitaci\u00f3 de l'her\u00e8ncia m\u00faltiple.</p> <p>Com veiem, la relaci\u00f3 entre una classe i la interf\u00edcie o interf\u00edcies que implementa \u00e9s amb la mateixa l\u00ednia discont\u00ednua que indic\u00e0vem les relacions d'her\u00e8ncia, amb un triangle/flexta a la interf\u00edcie.</p> <p>Per representar una intef\u00edcie en PlantUML fem \u00fas de la paraula clau interface en lloc de class:</p> <pre><code>``` plantuml\n@startuml\ninterface Dibuixable {\n  +Dibuixa() : void\n}\n\nclass Nau {\n  +Dibuixa() : void\n}\n\nNau ..|&gt; Dibuixable\n@enduml\n```\n</code></pre> <p>Que es representa marcant la interf\u00edcie amb una <code>I</code> i una l\u00ednia discont\u00ednua:</p> <p></p> <p>Per la seua banda, amb Mermaid, no fem \u00fas de la paraula inteface per definir la classe, per\u00f2 podem marcar una classe amb <code>&lt;&lt;interface&gt;&gt;</code> i expressar la relaci\u00f3 de implements amb <code>..|&gt;</code>:</p> <pre><code>``` mermaid\nclassDiagram\n    class Dibuixable {\n      &lt;&lt;interface&gt;&gt;\n        + Dibuixa()\n    }\n\n    class Nau {\n        + Dibuixa()\n    }\n\n    Nau ..|&gt; Dibuixable\n```\n</code></pre> <pre><code>classDiagram\n    class Dibuixable {\n      &lt;&lt;interface&gt;&gt;\n        + Dibuixa()\n    }\n\n    class Nau {\n        + Dibuixa()\n    }\n\n    Nau ..|&gt; Dibuixable</code></pre>"},{"location":"3.DiagramaClasses/#implementacio-en-java_1","title":"Implementaci\u00f3 en Java","text":"<p>En Java, definiriem la interf\u00edcie amb la paraula clau <code>interface</code>, i far\u00edem \u00fas de la paraula <code>implements</code> per indicar que una classe implementa aquesta interf\u00edcie:</p> <pre><code>public interface Dibuixable {\n  public void Dibuixa();\n}\n\npublic class Nau implements Dibuixable{\n\n  ...\n  public void Dibuixa(){\n      ...\n  }\n\n}\n</code></pre> <p>Per la seua banda, Javscript no suporta inter\u00edcies com a tal. En lloc d'aix\u00f2, podem optar per diverses opcions m\u00e9s avan\u00e7ades, com per exemple, fer \u00fas de classes abstractes (que limita la implementaci\u00f3 de m\u00faltiples interf\u00edcies), el duck typing, implementar mixins de manera manual, o fer \u00fas directament de typescript.</p>"},{"location":"3.DiagramaClasses/#3-dibuixant-diagrames-de-classes","title":"3. Dibuixant diagrames de classes","text":"<p>Els diagrames de classe estan associats al disseny orientat a objectes. A mode de gu\u00eda, els passos que generalment seguim a l'hora de realitzar aquest disseny seran els seg\u00fcents:</p> <ul> <li>Identificar les classes, que solen correspondre's a substantius dins el domini del problema (client, factura, jugador, etc.)</li> <li>Identificar les relacions  entre les diferents classes, els punts en com\u00fa i les abstraccions entre elles, de manera que ajude a agupar-los en dibuixar el diagrama de classes.</li> <li>Crear l'estructura fent \u00fas dels connectors apropiats entre les classes, donant especial atenci\u00f3 a la multiplicitat o les her\u00e8ncies. Els atributs i m\u00e8todes es perfilaran m\u00e9s tard, una vegada estiga l'estructura del diagrama resolta.</li> </ul> <p>Algunes bones pr\u00e0ctiques que podem tindre en compte a l'hora de generar diagrames de classes s\u00f3n:</p> <ul> <li>Quan els diagrames creixen poden tornar-se incoherents i poc clars. \u00c9s preferible crear diagrames menuts que despr\u00e9s pogam vincular entre ells que un gran diagrama que es preste a confussi\u00f3.</li> <li>Per comen\u00e7ar, podem fer \u00fas de la notaci\u00f3 de classe m\u00e9s simple per tindre una visi\u00f3 general d'alt nivell del sistema (pr\u00e0cticament un entitat-relaci\u00f3), i perfilar-lo despr\u00e9s amb els atributs i m\u00e8todes.</li> <li>Cal assegurar la major claredat en els diagrames, organitzant b\u00e9 les classes, i evitant coses com, per exemple que es creuen o superposen l\u00ednies que representen relacions, ja que es presta a confussi\u00f3.</li> <li>De vegades, tamb\u00e9 \u00e9s \u00fatil fer \u00fas de colors per agrupar m\u00f2duls comuns, i ajudar aix\u00ed al lector/client a diferenciar-los.</li> </ul>"},{"location":"4.DiagramesSequencia/","title":"4. Diagrama de seq\u00fc\u00e8ncia","text":""},{"location":"4.DiagramesSequencia/#diagrames-de-sequencia","title":"Diagrames de seq\u00fc\u00e8ncia","text":"<p>Els diagrames de seq\u00fc\u00e8ncia s\u00f3n un tipus de diagrama de comportament en UML que mostren la seq\u00fc\u00e8ncia d\u2019interaccions entre els diferents actors i subsistemes participants en els casos d'\u00fas, representats ara com classes del sistema.</p> <p>Aquests diagrames descriuen com interactuen els objectes entre si mitjan\u00e7ant missatges enviats en un ordre temporal, detallant el flux d'execuci\u00f3 d'un proc\u00e9s concret.</p>"},{"location":"4.DiagramesSequencia/#elements-principals-dun-diagrama-de-sequencia","title":"Elements principals d'un diagrama de seq\u00fc\u00e8ncia","text":"<p>Els diagrames de seq\u00fc\u00e8ncia es componen de diversos elements clau:</p>"},{"location":"4.DiagramesSequencia/#actors-i-objectes","title":"Actors i Objectes","text":"<p>Els diagrames de seq\u00fc\u00e8ncia representen entitats o components del sistema que participen en la comunicaci\u00f3. </p> <p>Aquestes entitats s'expressen amb un rectangle amb el seu nom a dalt i poden ser:</p> <ul> <li>Actors, que s\u00f3n les entitats externes al sistema(usuaris, sistemes extern,...).</li> <li>Objectes, que s\u00f3n les classes o inst\u00e0ncies que participen en el proc\u00e9s.</li> </ul>"},{"location":"4.DiagramesSequencia/#linies-de-vida","title":"L\u00ednies de vida","text":"<p>Les l\u00ednies de vida, o de temps, representen l'exist\u00e8ncia d'un objecte al llarg del temps.</p> <p>Aquestes es dibuixen com l\u00ednies verticals que parteixen de cada actor o objecte, i representen la seua evoluci\u00f3 al llarg del temps.</p>"},{"location":"4.DiagramesSequencia/#missatges","title":"Missatges","text":"<p>Els missatges indiquen comunicaci\u00f3 entre objectes i actors, i representen m\u00e8todes invocats en altres ojbectes.</p> <p>Aquests m\u00e8todes poden ser de diferents tipus:</p> <ul> <li>S\u00edncrons (<code>--&gt;</code> en PlantUML): L'emissor espera la resposta abans de continuar.</li> <li>Asincr\u00f2nics (<code>-&gt;</code> en PlantUML): L'emissor envia el missatge per\u00f2 no espera la resposta.</li> </ul>"},{"location":"4.DiagramesSequencia/#activacions","title":"Activacions","text":"<p>Una activaci\u00f3 representa el temps en qu\u00e8 un objecte est\u00e0 actiu processant una acci\u00f3.</p> <p>Es representen com blocs rectangulars a la l\u00ednia de vida.</p>"},{"location":"4.DiagramesSequencia/#retorns","title":"Retorns","text":"<p>Els retorns indiquen la resposta d'un missatge enviat. Es dibuixen amb una fletxa discont\u00ednua (<code>--&gt;&gt;</code> en PlantUML).</p>"},{"location":"4.DiagramesSequencia/#creacio-i-destruccio-dobjectes","title":"Creaci\u00f3 i Destrucci\u00f3 d\u2019Objectes","text":"<p>Un objecte pot ser creat durant el proc\u00e9s (<code>create</code> en PlantUML) i pot ser destru\u00eft (<code>destroy</code>), representat amb una \"X\" a la l\u00ednia de vida.</p>"},{"location":"4.DiagramesSequencia/#exemple-basic-de-diagrama-de-sequencia","title":"Exemple b\u00e0sic de diagrama de seq\u00fc\u00e8ncia","text":"<p>Veiem un exemple que representa el proc\u00e9s de realitzaci\u00f3 d\u2019un enc\u00e0rrec en una botiga en l\u00ednia.</p>"},{"location":"4.DiagramesSequencia/#representacio-en-plantuml","title":"Representaci\u00f3 en PlantUML","text":"<pre><code>``` plantuml\n@startuml\nactor Usuari\nparticipant \"Sistema e-Commerce\" as Sistema\nparticipant \"Base de Dades\" as BD\n\nUsuari -&gt; Sistema : Inicia sessi\u00f3\nSistema -&gt; BD : Verifica credencials\nBD --&gt;&gt; Sistema : Credencials v\u00e0lides\nSistema --&gt;&gt; Usuari : Acc\u00e9s concedit\n\nUsuari -&gt; Sistema : Afegeix producte al carret\nSistema -&gt; BD : Guarda producte al carret\nBD --&gt;&gt; Sistema : Confirmaci\u00f3\n\nUsuari -&gt; Sistema : Finalitza compra\nSistema -&gt; BD : Guarda comanda\nBD --&gt;&gt; Sistema : Confirmaci\u00f3\nSistema --&gt;&gt; Usuari : Compra completada\n@enduml\n```\n</code></pre> <p>Que es representa de la seg\u00fcent manera:</p> <p></p>"},{"location":"4.DiagramesSequencia/#representacio-en-mermaid","title":"Representaci\u00f3 en Mermaid","text":"<pre><code>``` mermaid\nsequenceDiagram\n    participant Usuari\n    participant Sistema\n    participant BD as Base de Dades\n\n    Usuari-&gt;&gt;Sistema: Inicia sessi\u00f3\n    Sistema-&gt;&gt;BD: Verifica credencials\n    BD--&gt;&gt;Sistema: Credencials v\u00e0lides\n    Sistema--&gt;&gt;Usuari: Acc\u00e9s concedit\n\n    Usuari-&gt;&gt;Sistema: Afegeix producte al carret\n    Sistema-&gt;&gt;BD: Guarda producte al carret\n    BD--&gt;&gt;Sistema: Confirmaci\u00f3\n\n    Usuari-&gt;&gt;Sistema: Finalitza compra\n    Sistema-&gt;&gt;BD: Guarda comanda\n    BD--&gt;&gt;Sistema: Confirmaci\u00f3\n    Sistema--&gt;&gt;Usuari: Compra completada\n```\n</code></pre> <p>Que es representa aix\u00ed:</p> <pre><code>sequenceDiagram\n    participant Usuari\n    participant Sistema\n    participant BD as Base de Dades\n\n    Usuari-&gt;&gt;Sistema: Inicia sessi\u00f3\n    Sistema-&gt;&gt;BD: Verifica credencials\n    BD--&gt;&gt;Sistema: Credencials v\u00e0lides\n    Sistema--&gt;&gt;Usuari: Acc\u00e9s concedit\n\n    Usuari-&gt;&gt;Sistema: Afegeix producte al carret\n    Sistema-&gt;&gt;BD: Guarda producte al carret\n    BD--&gt;&gt;Sistema: Confirmaci\u00f3\n\n    Usuari-&gt;&gt;Sistema: Finalitza compra\n    Sistema-&gt;&gt;BD: Guarda comanda\n    BD--&gt;&gt;Sistema: Confirmaci\u00f3\n    Sistema--&gt;&gt;Usuari: Compra completada</code></pre>"},{"location":"4.DiagramesSequencia/#creacio-i-destruccio-en-plantuml-i-mermaid","title":"Creaci\u00f3 i destrucci\u00f3 en PlantUML i Mermaid","text":"<p>Veiem com incorporar la creaci\u00f3 i destrucci\u00f3 d'objecte en PlantUml i Mermaid amb el seg\u00fcent exemple:</p> <pre><code>![Diagrama UML](../diagrames/4.DiagramesSequencia/diagram_7339730524963687279.svg)\n</code></pre> <p>Que es representa de la seg\u00fcent forma:</p> <p></p> <p>En Mermaid, l'exemple anterior es representaria amb:</p> <pre><code>``` mermaid\nsequenceDiagram\n    participant Usuari\n    participant Sistema\n    participant Comanda\n\n    Usuari-&gt;&gt;Sistema: Crea una nova comanda\n    Sistema-&gt;&gt;Comanda: Inicialitza Comanda\n    activate Comanda\n    Sistema-&gt;&gt;Comanda: Guarda detalls\n    Sistema-&gt;&gt;Comanda: Finalitza comanda\n    deactivate Comanda\n    Sistema--&gt;&gt;Usuari: Comanda completada\n```\n</code></pre> <p>I tindria la seg\u00fcent representaci\u00f3:</p> <pre><code>sequenceDiagram\n    participant Usuari\n    participant Sistema\n    participant Comanda\n\n    Usuari-&gt;&gt;Sistema: Crea una nova comanda\n    Sistema-&gt;&gt;Comanda: Inicialitza Comanda\n    activate Comanda\n    Sistema-&gt;&gt;Comanda: Guarda detalls\n    Sistema-&gt;&gt;Comanda: Finalitza comanda\n    deactivate Comanda\n    Sistema--&gt;&gt;Usuari: Comanda completada</code></pre> <p>Refer\u00e8ncies</p> <ul> <li>Diagamas de secuencia</li> <li>Diagrames de seq\u00fcencia en PlantUML</li> <li>Diagrames de seq\u00fc\u00e8ncia en Mermaid</li> </ul>"},{"location":"5.DiagramaComponents/","title":"5. Diagrama de Components","text":""},{"location":"5.DiagramaComponents/#diagrama-de-components","title":"Diagrama de components","text":"<p>Els diagrames de components s\u00f3n un tipus de diagrama estructural en UML que mostra com les diferents parts d'un sistema estan organitzades i com interactuen entre si. Es fan servir per representar l\u2019arquitectura f\u00edsica i l\u2019estructura de les depend\u00e8ncies en un sistema complex.</p> <p>A difer\u00e8ncia dels diagrames de classes, que descriuen el model conceptual i l\u2019estructura l\u00f2gica d\u2019un sistema, els diagrames de components mostren com les diferents parts s'agrupen en components reutilitzables i com aquests components es comuniquen entre ells.</p>"},{"location":"5.DiagramaComponents/#elements-dun-diagrama-de-components","title":"Elements d'un diagrama de components","text":"<p>Els diagrames de components es componen principalment dels seg\u00fcents elements:</p>"},{"location":"5.DiagramaComponents/#components","title":"Components","text":"<ul> <li>Representen m\u00f2duls o unitats del sistema que encapsulen una funcionalitat espec\u00edfica.</li> <li>Es dibuixen com rectangles amb dues caixes menudes als costats.</li> <li>Cada component pot representar una biblioteca, un m\u00f2dul, un servei, un microservei, etc.</li> </ul>"},{"location":"5.DiagramaComponents/#interficies-i-connectors","title":"Interf\u00edcies i Connectors","text":"<ul> <li>Els components es comuniquen a trav\u00e9s d\u2019interf\u00edcies.</li> <li>Les interf\u00edcies proporcionades (el component ofereix funcionalitat) es representen amb un semicercle (<code>\u25e6</code>).</li> <li>Les interf\u00edcies requerides (el component necessita funcionalitat d\u2019un altre component) es representen amb un connector tipus socket (<code>\u2282</code>).</li> </ul>"},{"location":"5.DiagramaComponents/#dependencies","title":"Depend\u00e8ncies","text":"<ul> <li>Indiquen com es relacionen els components mitjan\u00e7ant l\u00ednies de connexi\u00f3.</li> <li>Es poden representar amb una fletxa de depend\u00e8ncia (<code>--&gt;</code>) per indicar que un component dep\u00e8n d'un altre.</li> </ul>"},{"location":"5.DiagramaComponents/#exemple-basic-de-diagrama-de-components","title":"Exemple b\u00e0sic de diagrama de components","text":"<p>Veiem un exemple d'un sistema de compres en l\u00ednia, on diferents components interactuen entre si.</p>"},{"location":"5.DiagramaComponents/#representacio-en-plantuml","title":"Representaci\u00f3 en PlantUML","text":"<p>Un sistema bastant com\u00fa de compres en l\u00ednia es podria representar amb el seg\u00fcent diagrama de components:</p> <p></p> <p>Aquest diagrama est\u00e0 estructurat dins d'un paquet (<code>package \"Sistema e-Commerce\"</code>), que agrupa els components del sistema. Aix\u00f2 ajuda a organitzar millor el diagrama quan tenim molts components. </p> <p>Aquests components s\u00f3n:</p> Component Funci\u00f3 Frontend Interf\u00edcie d'usuari, aplicaci\u00f3 web o m\u00f2bil que interactua amb el sistema. Backend Gestor de la l\u00f2gica de negoci, gestiona la base de dades i interacciona amb serveis externs. Base de Dades Emmagatzema informaci\u00f3 del sistema (usuaris, comandes, productes, etc.). Servei de Pagament Passarel\u00b7la de pagament externa que permet processar transaccions. Banc Entitat financera que valida i autoritza els pagaments. <p>I les connexions entre aquests components s\u00f3n:</p> Connexi\u00f3 Descripci\u00f3 <code>Frontend --&gt; Backend : API REST</code> El Frontend (app web/m\u00f2bil) interactua amb el Backend a trav\u00e9s d'una API REST. <code>Backend --&gt; Base de Dades : Consultes SQL</code> El Backend consulta i actualitza la Base de Dades mitjan\u00e7ant SQL. <code>Backend --&gt; Servei de Pagament : Connexi\u00f3 amb passarel\u00b7la</code> El Backend s\u2019encarrega d'enviar informaci\u00f3 de pagament a una passarel\u00b7la de pagament externa (ex: PayPal, Stripe). <code>Servei de Pagament --&gt; Banc : Transacci\u00f3 banc\u00e0ria</code> El Servei de Pagament envia la sol\u00b7licitud de transacci\u00f3 a l'entitat banc\u00e0ria, que l\u2019aprova o la rebutja. <p>El funcionament d'aquests compoents \u00e9s el seg\u00fcent:</p> <ol> <li>Un usuari accedeix al Frontend (una web o aplicaci\u00f3 m\u00f2bil).</li> <li>El Frontend sol\u00b7licita informaci\u00f3 al Backend a trav\u00e9s de peticions API REST.</li> <li>El Backend consulta la Base de Dades per obtenir informaci\u00f3 sobre productes, ordres o usuaris.</li> <li>Quan un usuari realitza una compra, el Backend envia una sol\u00b7licitud de pagament a un Servei de Pagament extern.</li> <li>El Servei de Pagament contacta amb el Banc per processar la transacci\u00f3.</li> <li>El Banc confirma o rebutja la transacci\u00f3 i retorna la resposta al Servei de Pagament.</li> <li>El Servei de Pagament informa el Backend de l'estat de la transacci\u00f3.</li> <li>El Backend actualitza la Base de Dades i envia la confirmaci\u00f3 al Frontend.</li> </ol>"},{"location":"5.DiagramaComponents/#representacio-amb-plantuml","title":"Representaci\u00f3 amb PlantUML","text":"<p>El diagrama anterior, es representaria amb:</p> <pre><code>``` plantuml\npackage \"Sistema e-Commerce\" {\n    [Frontend] --&gt; [Backend] : API REST\n    [Backend] --&gt; [Base de Dades] : Consultes SQL\n    [Backend] --&gt; [Servei de Pagament] : Connexi\u00f3 amb passarel\u00b7la\n    [Servei de Pagament] --&gt; [Banc] : Transacci\u00f3 banc\u00e0ria\n}\n@enduml\n```\n</code></pre>"},{"location":"5.DiagramaComponents/#representacio-en-mermaid","title":"Representaci\u00f3 en Mermaid","text":"<p>El diagrama anterior podr\u00eda representar-se amb Mermaid com a un diagrama de flux:</p> <pre><code>``` mermaid\ngraph TD\n    subgraph \"Sistema e-Commerce\"\n        Frontend --&gt;|API REST| Backend\n        Backend --&gt;|Consultes SQL| BaseDeDades\n        Backend --&gt;|Connexi\u00f3 amb passarel\u00b7la| ServeiDePagament\n        ServeiDePagament --&gt;|Transacci\u00f3 banc\u00e0ria| Banc\n    end\n```\n</code></pre> <p>Que es representar\u00e0 aix\u00ed:</p> <pre><code>graph TD\n    subgraph \"Sistema e-Commerce\"\n        Frontend --&gt;|API REST| Backend\n        Backend --&gt;|Consultes SQL| BaseDeDades\n        Backend --&gt;|Connexi\u00f3 amb passarel\u00b7la| ServeiDePagament\n        ServeiDePagament --&gt;|Transacci\u00f3 banc\u00e0ria| Banc\n    end</code></pre>"},{"location":"5.DiagramaComponents/#que-aporten-els-diagrames-de-components","title":"Qu\u00e8 aporten els diagrames de components?","text":"<ul> <li>Els diagrames de components s\u00f3n de gran import\u00e0ncia per comprendre l'arquitectura d'un sistema i com les parts interactuen entre si.</li> <li>PlantUML i Mermaid permeten representar-los de manera senzilla i eficient.</li> <li>S\u00f3n \u00fatils per documentar aplicacions modernes, especialment aquelles basades en microserveis i arquitectures distribu\u00efdes.</li> </ul>"},{"location":"6.UMLAgil/","title":"6.UMLAgil","text":""},{"location":"6.UMLAgil/#uml-i-metodologies-agils","title":"UML i Metodologies \u00c0gils","text":"<p>Les metodologies \u00e0gils com SCRUM i Agile, o el desenvolupament en espiral i iteratiu es basen en la creaci\u00f3 de productes de manera incremental, amb una estreta col\u00b7laboraci\u00f3 amb el client, retroalimentaci\u00f3 cont\u00ednua i entregues freq\u00fcents de versions funcionals. En canvi, UML sovint s\u2019associa amb metodologies tradicionals m\u00e9s predictives, com el model en cascada, on la fase de disseny es realitza de manera exhaustiva abans de comen\u00e7ar la implementaci\u00f3.</p> <p>Tot i aix\u00f2, UML pot adaptar-se perfectament al desenvolupament \u00e0gil si s'utilitza amb un enfocament iteratiu i centrat en el valor. La clau \u00e9s entendre UML com una eina flexible que s'ha d'adaptar a les necessitats del projecte i no com una estructura r\u00edgida. Veiem com fer-ho compatible.</p>"},{"location":"6.UMLAgil/#1-principis-de-les-metodologies-agils","title":"1. Principis de les metodologies \u00e0gils","text":"<p>Recordem que les metodologies \u00e0gils parteixen de quatre valors fonamentals i dotze principis establerts en el Manifest \u00c0gil. Alguns d\u2019aquests principis s\u00f3n:</p> <ul> <li>Entregues freq\u00fcents i funcionals: Es treballa en iteracions curtes (sprints) que proporcionen programari funcional.</li> <li>Resposta r\u00e0pida al canvi: Es prioritzen els canvis en els requeriments per adaptar-se millor a les necessitats del client.</li> <li>Col\u00b7laboraci\u00f3 amb el client: La implicaci\u00f3 del client \u00e9s constant durant tot el proc\u00e9s.</li> </ul>"},{"location":"6.UMLAgil/#2-compatibilitzant-uml-i-metodologies-agils","title":"2. Compatibilitzant UML i metodologies \u00e0gils","text":"<p>Quan s\u2019utilitza UML en metodologies \u00e0gils, poden apar\u00e9ixer alguns reptes aparentment contradictoris:</p> <ul> <li>Disseny inicial vs. iteracions curtes: UML sol requerir un disseny previ detallat (especialment diagrames de classes i components).</li> <li>Documentaci\u00f3 m\u00ednima: Les metodologies \u00e0gils aposten per una documentaci\u00f3 lleugera i \u00fatil, mentre que UML pot generar molta documentaci\u00f3.</li> <li>Adaptabilitat: Cal que el disseny UML s'adapte r\u00e0pidament als canvis de requeriments.</li> </ul>"},{"location":"6.UMLAgil/#3-com-per-integrar-uml-en-metodologies-agils","title":"3. Com per integrar UML en metodologies \u00e0gils?","text":"<p>Veiem diverses estrat\u00e8gies per poder utilitzar UML de manera efectiva en un entorn \u00e0gil:</p>"},{"location":"6.UMLAgil/#31-disseny-evolutiu","title":"3.1. Disseny evolutiu","text":"<ul> <li>No es fa un disseny complet al principi.  </li> <li>Es comen\u00e7a al primer sprint amb diagrames UML senzills centrats en els casos d'\u00fas i classes b\u00e0siques.  </li> <li>A mesura que s\u2019incorporen noves funcionalitats en sprints posteriors, es completen i actualitzen els diagrames.</li> </ul>"},{"location":"6.UMLAgil/#32-documentacio-minima-i-util","title":"3.2. Documentaci\u00f3 m\u00ednima i \u00fatil","text":"<ul> <li>Cal centrar-se en els diagrames estrictament necessaris per a la comunicaci\u00f3 i el desenvolupament.  </li> <li>Utilitzarem Mermaid o PlantUML per generar diagrames r\u00e0pids i integrables en documentaci\u00f3 Markdown (per exemple, en GitHub o MkDocs).  </li> <li>Es pot adoptar la pr\u00e0ctica de documentar nom\u00e9s aquelles parts del sistema que canvien amb freq\u00fc\u00e8ncia o que tenen una l\u00f2gica complexa.</li> </ul>"},{"location":"6.UMLAgil/#33-uml-i-scrum","title":"3.3. UML i SCRUM","text":"<p>SCRUM organitza el desenvolupament en sprints amb objectius concrets. UML pot ser \u00fatil en:</p> <ul> <li>Sprint Planning: Es poden crear diagrames de seq\u00fc\u00e8ncia per il\u00b7lustrar el flux d'una nova funcionalitat.  </li> <li>Sprint Review: S'actualitzen diagrames de components per reflectir canvis en l'arquitectura.  </li> <li>Sprint Retrospective: Es revisa si la documentaci\u00f3 UML est\u00e0 sent \u00fatil i es decideix si cal simplificar-la.</li> </ul>"},{"location":"6.UMLAgil/#4-bones-practiques-per-a-uml-en-entorns-agils","title":"4. Bones pr\u00e0ctiques per a UML en entorns \u00e0gils","text":"<ul> <li>Prioritzar la simplicitat: Mantindre els diagrames nets i clars.  </li> <li>Refactoritzar diagrames peri\u00f2dicament: Igual que el codi, els diagrames han de reflectir l\u2019estat actual del sistema.  </li> <li>Integraci\u00f3 amb eines col\u00b7laboratives: Utilitzar eines com Mermaid, PlantUML o Lucidchart per generar diagrames directament dins de les eines de gesti\u00f3 de projectes (per exemple Jira o Confluence).</li> </ul>"},{"location":"7.Exercicis/","title":"7.Exercicis","text":""},{"location":"7.Exercicis/#el-just-eat-pizza-aplicacio-web-per-a-una-pizzeria","title":"El Just Eat Pizza: Aplicaci\u00f3 web per a una pizzeria","text":"<p>Anem a desenvolupar una aplicaci\u00f3 web per a la gesti\u00f3 dels enc\u00e0rregs d'una pizzeria.</p> <p>Treballarem en diferents Sprints, de manera que en cadascun anirem afegint nous requeriments i funcionalitats.</p>"},{"location":"7.Exercicis/#sprint-1-consulta-del-cataleg","title":"Sprint 1: Consulta del cat\u00e0leg","text":"<p>El primer sprint consistir\u00e0 en la creaci\u00f3 del sistema de consultes de la pizzeria.</p>"},{"location":"7.Exercicis/#activitat-objectius","title":"Activitat. Objectius.","text":"<p>Desenvolupar el disseny UML d'un sistema client-servidor per a la gesti\u00f3 i consulta de pizzes d'una pizzeria. El sistema ha d'oferir als clients la possibilitat de consultar les pizzes disponibles mitjan\u00e7ant una interf\u00edcie web basada en WebComponents.  </p> <p>Es demana:</p> <ul> <li>Implementar el cas d'\u00fas \"Consultar Pizzes\".  </li> <li>Dissenyar els diagrames UML necessaris per documentar el proc\u00e9s:  </li> <li>Diagrama de casos d'\u00fas.  </li> <li>Diagrama de classes.  </li> <li>Diagrama de seq\u00fc\u00e8ncia.  </li> <li>Diagrama de components.  </li> </ul> <p>Note</p> <p>Aquest exercici esn ajudar\u00e0 a entendre com es pot integrar UML amb una arquitectura basada en WebComponents i a aprofundir en la comunicaci\u00f3 client-servidor amb API REST.  </p>"},{"location":"7.Exercicis/#descripcio-funcional-del-cas-dus-consultar-pizzes","title":"Descripci\u00f3 funcional del cas d'\u00fas \"Consultar Pizzes\"","text":"<p>L'objectiu del cas d'\u00fas \u00e9s permetre que un client puga visualitzar les pizzes disponibles al men\u00fa de la pizzeria a trav\u00e9s d'una interf\u00edcie web.  </p>"},{"location":"7.Exercicis/#flux-principal","title":"Flux principal","text":"<ol> <li>El client accedeix al sistema mitjan\u00e7ant el navegador web.  </li> <li>El sistema client realitza una petici\u00f3 a l'API del servidor per consultar les pizzes.  </li> <li>El servidor rep la petici\u00f3, consulta la base de dades i retorna la llista de pizzes disponibles.  </li> <li>El sistema client rep la llista, la formata i la mostra a l'usuari utilitzant webcomponents.  </li> </ol>"},{"location":"7.Exercicis/#excepcions","title":"Excepcions:","text":"<ul> <li> <p>Error en la connexi\u00f3:   Si es produeix un error en la comunicaci\u00f3 amb el servidor, es mostra un missatge d'error a l'usuari.  </p> </li> <li> <p>Llista buida:   Si la llista de pizzes \u00e9s buida, es notifica a l'usuari que no hi ha pizzes disponibles actualment.  </p> </li> </ul>"},{"location":"7.Exercicis/#arquitectura-del-sistema","title":"Arquitectura del sistema","text":"<p>L'arquitectura es basa en un model client-servidor:</p> <ul> <li>Client: Aplicaci\u00f3 web basada en WebComponents.</li> <li>Servidor: Ofereix una API REST per a consultar la llista de pizzes.  </li> <li>Base de dades: Emmagatzema les dades de les pizzes.  </li> </ul>"},{"location":"7.Exercicis/#detall-tecnic-dels-components","title":"Detall t\u00e8cnic dels components","text":"<ol> <li>Classe <code>Pizza</code> </li> <li> <p>Cont\u00e9 la informaci\u00f3 de cada pizza:  </p> <ul> <li><code>id</code>, <code>nom</code>, <code>desc</code>, <code>vegetariana</code>, <code>alergens</code>, <code>preu</code> i <code>img</code>.  </li> </ul> </li> <li> <p>Classe <code>PizzaCard</code> (WebComponent)</p> </li> <li>Hereta de <code>HTMLElement</code>.  </li> <li> <p>Rep un objecte <code>Pizza</code> i mostra la seua informaci\u00f3 de forma visual.  </p> </li> <li> <p>M\u00f2dul de comunicaci\u00f3 </p> </li> <li> <p>Gestiona les peticions al servidor mitjan\u00e7ant fetch a una API REST.  </p> </li> </ol>"},{"location":"7.Exercicis/#alguns-aspectes-a-considerar","title":"Alguns aspectes a considerar","text":"<ol> <li>Com integrar les classes que defineixen la interf\u00edcie en el diagrama de classes?  Aquestes es poden incloure al diagrama principal o en un diagrama espec\u00edfic d\u2019interf\u00edcie d'usuari.  </li> <li>Com representar correctament la comunicaci\u00f3 entre client i servidor en UML? Utilitzarem un diagrama de seq\u00fc\u00e8ncia per descriure aquesta comunicaci\u00f3.  </li> <li>Com diferenciar les responsabilitats del client i del servidor? El diagrama de components ens ajudar\u00e0 a identificar les responsabilitats i les depend\u00e8ncies.  </li> </ol>"},{"location":"7.Exercicis/#activitat","title":"Activitat","text":"<p>A partir d'aquesta descripci\u00f3, es demana:  </p> <ol> <li> <p>Diagrama de casos d'\u00fas: </p> <ul> <li>Representar el cas d'\u00fas \"Consultar Pizzes\" amb actors, casos d'\u00fas i relacions.  </li> </ul> </li> <li> <p>Diagrama de classes: </p> <ul> <li>Incloure les classes necess\u00e0ries per al primer sprint (m\u00ednim: <code>Pizza</code>, <code>PizzaCard</code>, <code>PizzaService</code>).  </li> <li>Analitzar si la classe <code>PizzaCard</code> ha d'apar\u00e8ixer en aquest diagrama o en un de separat.  </li> </ul> </li> <li> <p>Diagrama de seq\u00fc\u00e8ncia: </p> <ul> <li>Mostrar com es realitza la interacci\u00f3 client-servidor per a obtenir i mostrar les pizzes.  </li> </ul> </li> <li> <p>Diagrama de components: </p> <ul> <li>Esquematitzar l'arquitectura del sistema, diferenciant clarament les parts del client i del servidor.  </li> </ul> </li> </ol> <p>Ves a la soluci\u00f3!</p>"},{"location":"8.Sprint2/","title":"8.Sprint2","text":""},{"location":"8.Sprint2/#el-just-eat-pizza-sprint-2","title":"El Just Eat Pizza. Sprint 2","text":"<p>En aquest segon Sprint, anem a incorporar un nou cas d'\u00fas senzill per a la consulta d'entrants, i molt semblant a l'anterior.</p> <p>Afegirem:</p> <ul> <li>El diagrama de casos d\u2019\u00fas per consultar entrants i la seua corresponent especificaci\u00f3</li> <li>El diagrama de classes adaptant el model.</li> <li>El diagrama de seq\u00fc\u00e8ncia per reflectir la consulta d\u2019entrants.</li> <li>el diagrama de components per mostrar la interacci\u00f3 dels nous m\u00f2duls.</li> </ul>"},{"location":"8.Sprint2/#diagrama-de-casos-dus","title":"Diagrama de casos d'\u00fas","text":"<p>Aquest diagrama Consultar Entrants mostrar\u00e0 l'actor principal (el client) i les interaccions amb el sistema per realitzar l'acci\u00f3.</p> <p></p> <p>Per tant, la integraci\u00f3 amb el cas anterior quedaria:</p> <p></p> <p>L'especificaci\u00f3 de requeriments funcionals per a aquest segon cas d'\u00fas tindr\u00e0 el seg\u00fcent aspecte:</p>"},{"location":"8.Sprint2/#cas-dus-rf02","title":"Cas d'\u00fas: RF02","text":"<ul> <li>Nom: Consultar Entrants  </li> <li>Actors: Client  </li> <li>Descripci\u00f3: El client consulta el men\u00fa d'entrants disponibles a trav\u00e9s de la interf\u00edcie web.  </li> <li>Precondicions: El client ha d'accedir a la web.  </li> <li>Postcondicions: Es mostra la llista d'entrants o un missatge d'error si hi ha algun problema.  </li> </ul>"},{"location":"8.Sprint2/#flux-principal","title":"Flux principal","text":"<ol> <li>El client accedeix al sistema mitjan\u00e7ant el navegador.  </li> <li>El sistema mostra la llista d'entrants disponibles a la secci\u00f3 corresponent.</li> </ol>"},{"location":"8.Sprint2/#fluxos-alternatius-excepcions","title":"Fluxos alternatius (excepcions)","text":"<ul> <li>Error de connexi\u00f3: El sistema mostra un missatge d'error si no es pot contactar amb el servidor.  </li> <li>Llista buida: Si no hi ha entrants disponibles, s\u2019informa l'usuari que el men\u00fa est\u00e0 buit.  </li> </ul>"},{"location":"8.Sprint2/#diagrama-de-classes","title":"Diagrama de classes","text":"<p>Per tal d'implementar aquest nou cas d'\u00fas, identificarem les seg\u00fcents classes noves, fent una distinci\u00f3 entre les classes pr\u00f2pies del domini i les classes que es corresponene al a implementaci\u00f3 del servei.</p> <ul> <li>1. Classes del model (domini)<ul> <li><code>Entrant</code>: Representa un entrant amb les seues caracter\u00edstiques.  </li> </ul> </li> <li>2. Classes de servei <ul> <li><code>PizzeriaService</code>: Gestiona la comunicaci\u00f3 amb el servidor per obtenir la llista d'entrants.</li> </ul> </li> <li>3. Classes de la interf\u00edcie (WebComponents)<ul> <li><code>EntrantCard</code>: WebComponent que representa visualment un entrant.  </li> </ul> </li> </ul> <p></p>"},{"location":"8.Sprint2/#integracio-de-la-biblioteca-de-components-i-refactoritzacio","title":"Integraci\u00f3 de la biblioteca de components i refactoritzaci\u00f3","text":"<p>En aquest sprint, s'ha incorporat la biblioteca de components, la qual estructura els WebComponents de manera jer\u00e0rquica. Els components ara s'organitzen aix\u00ed:</p> <ul> <li><code>EntrantCard</code> ara descendeix de <code>CardComponent</code>, aprofitant una implementaci\u00f3 comuna per a targetes de productes.</li> <li><code>CardComponent</code> hereta de <code>BaseComponent</code>, que proporciona una estructura b\u00e0sica per a components.</li> <li><code>BaseComponent</code> descendeix de <code>HTMLElement</code>, garantint que tota la l\u00f2gica comuna es centralitze en una sola classe base.</li> </ul> <p>A m\u00e9s, s'ha refactoritzat el model de dades:</p> <ul> <li>S'ha creat la classe <code>Producte</code>, que encapsula atributs comuns entre <code>Pizza</code> i <code>Entrant</code>.</li> <li><code>Pizza</code> i <code>Entrant</code> ara hereten de <code>Producte</code>, facilitant la reutilitzaci\u00f3 de codi i afegint consist\u00e8ncia a la implementaci\u00f3.</li> </ul> <p>Veiem com queden reflexats aquests canvis al diagrama de classes</p> <p></p>"},{"location":"8.Sprint2/#diagrama-de-sequencia","title":"Diagrama de seq\u00fc\u00e8ncia","text":"<p>Aquest diagrama mostrar\u00e0 la seq\u00fc\u00e8ncia d'interaccions necess\u00e0ria perqu\u00e8 el client puga consultar els entrants disponibles.</p> <p></p>"},{"location":"8.Sprint2/#diagrama-de-components","title":"Diagrama de components","text":"<p>Veiem com queda el diagrama de components amb l'arquitectura del sistema i la interacci\u00f3 entre els diferents m\u00f2duls.</p> <p></p> <p>Implementaci\u00f3</p> <p>Consulteu la implementaci\u00f3 d'aquest sprint</p>"},{"location":"9.Sprint3/","title":"9.Sprint3","text":""},{"location":"9.Sprint3/#sprint-3-afegir-un-carret-de-la-compra","title":"Sprint 3. Afegir un carret de la compra","text":"<p>En aquest sprint anem a afegir una nova funcionalitat i incorporar un carret de la compra, que ens permeta afegir i eliminar productes per fer un enc\u00e0rrec. Es podran consultar els productes del carret i modificar-ne la seua quantitat des del mateix carret</p> <p>A m\u00e9s, a la part superior, junt amb el t\u00edtol de l'aplicaci\u00f3, apareixer\u00e0 informaci\u00f3 del carret, on es mostrar\u00e0 la quantitat de productes que hi ha i el preu total de l'enc\u00e0rrec.</p>"},{"location":"9.Sprint3/#diagrama-de-casos-dus","title":"Diagrama de casos d'\u00fas","text":"<p>Les dues accions principals que aportar\u00e0 aquest sprint seran\u00a0afegir un producte i eliminar un producte.</p> <p></p> <p>L'especificaci\u00f3 dels requeriments funcionals d'aquests casos d'\u00fas \u00e9s la seg\u00fcent:</p>"},{"location":"9.Sprint3/#cas-dus-rf03-afegir-producte-al-carret","title":"Cas d'\u00fas: RF03 - Afegir producte al carret","text":"<ul> <li>Nom: Afegir producte al carret</li> <li>Actors: Client</li> <li>Descripci\u00f3: El client fa clic al bot\u00f3 (+) d\u2019un producte (tant des de la pestanya de productes com des del carret) i aquest s\u2019afegeix al carret de la compra.</li> <li>Precondicions: El client ha d'accedir a la web i veure el men\u00fa de productes.</li> <li>Postcondicions: El producte s'afegeix al carret i s'actualitza la quantitat i el preu total a la barra del t\u00edtol.</li> </ul>"},{"location":"9.Sprint3/#flux-principal","title":"Flux principal","text":"<ol> <li>El client visualitza la llista de productes o el carret.</li> <li>El client fa clic al bot\u00f3 (+) d'un producte.</li> <li>El sistema afegeix el producte al carret.</li> <li>La quantitat i el preu total s\u2019actualitzen a la barra del t\u00edtol.</li> </ol>"},{"location":"9.Sprint3/#fluxos-alternatius-excepcions","title":"Fluxos alternatius (excepcions)","text":"<ul> <li>Error en l\u2019operaci\u00f3: Si hi ha un problema afegint productes, es mostra un missatge d'error.</li> </ul>"},{"location":"9.Sprint3/#cas-dus-rf04-eliminar-producte-del-carret","title":"Cas d'\u00fas: RF04 - Eliminar producte del carret","text":"<ul> <li>Nom: Eliminar producte del carret</li> <li>Actors: Client</li> <li>Descripci\u00f3: El client pot eliminar un producte del carret des de dues ubicacions:</li> <li>Directament des del llistat de productes (pizzes o entrants) fent clic al bot\u00f3 <code>-</code>.</li> <li>Des de la pestanya del carret, on pot reduir unitats o eliminar un producte completament.</li> <li>Precondicions: Ha d\u2019haver almenys una unitat del producte al carret.</li> <li>Postcondicions: La quantitat i el preu total s'actualitzen a la barra del t\u00edtol. Si el producte arriba a 0 unitats, desapareix del carret.</li> </ul>"},{"location":"9.Sprint3/#flux-principal_1","title":"Flux principal","text":"<ol> <li>El client visualitza la llista de productes o el carret.</li> <li>El client fa clic al bot\u00f3 (-) d'un producte.</li> <li>El sistema redueix la quantitat d\u2019aquell producte en el carret.</li> <li>La quantitat i el preu total s\u2019actualitzen a la barra del t\u00edtol.</li> <li>Si la quantitat arriba a 0, el producte s\u2019elimina del carret.</li> </ol>"},{"location":"9.Sprint3/#fluxos-alternatius-excepcions_1","title":"Fluxos alternatius (excepcions)","text":"<ul> <li>Error en l\u2019operaci\u00f3: Si hi ha un problema en la reducci\u00f3, es mostra un missatge d'error.</li> </ul>"},{"location":"9.Sprint3/#cas-dus-rf05-consultar-el-carret","title":"Cas d'\u00fas: RF05 - Consultar el carret","text":"<ul> <li>Nom: Consultar el carret</li> <li>Actors: Client</li> <li>Descripci\u00f3: El client pot accedir a la pestanya del carret per veure els productes afegits, la seua quantitat i el preu total.</li> <li>Precondicions: Ha d'haver almenys un producte al carret per a mostrar informaci\u00f3.</li> <li>Postcondicions: Es mostra la llista de productes amb la seua quantitat i el preu total.</li> </ul>"},{"location":"9.Sprint3/#flux-principal_2","title":"Flux principal","text":"<ol> <li>El client accedeix a la pestanya del carret.</li> <li>El sistema mostra la llista de productes afegits.</li> <li>Es visualitzen la quantitat de cada producte i el preu total de la comanda.</li> </ol>"},{"location":"9.Sprint3/#fluxos-alternatius-excepcions_2","title":"Fluxos alternatius (excepcions)","text":"<ul> <li>El carret est\u00e0 buit: Es mostra un missatge indicant que el client encara no ha afegit productes.</li> </ul>"},{"location":"9.Sprint3/#diagrama-de-classes","title":"Diagrama de classes","text":"<p>Veiem la part del diagrama de classes que es correspondr\u00e0 nom\u00e9s a aquesta cas d'\u00fas. En ell veiem l'estructura del carret, com es relaciona amb els productes, i com es representa amb un component.</p> <p></p>"},{"location":"9.Sprint3/#diagrama-de-sequencia","title":"Diagrama de seq\u00fc\u00e8ncia","text":"<p>Aquest diagrama mostra la interacci\u00f3 entre l\u2019usuari, el carret i la interf\u00edcie quan es realitza una acci\u00f3 d\u2019afegir o eliminar un producte al carret.</p> <p></p>"},{"location":"9.Sprint3/#diagrama-de-components","title":"Diagrama de components","text":"<p>Aquest diagrama mostra la relaci\u00f3 entre els diferents components del sistema, incloent el fet que <code>ProducteCard</code> tamb\u00e9 interactua amb el carret.</p> <p></p> <p>Implementaci\u00f3</p> <p>Consulteu la implementaci\u00f3 d'aquest sprint</p>"},{"location":"Sprint1_Pizzes/","title":"Sprint1 Pizzes","text":""},{"location":"Sprint1_Pizzes/#resolucio-de-lsprint-1","title":"Resoluci\u00f3 de l'sprint 1","text":""},{"location":"Sprint1_Pizzes/#diagrama-de-casos-dus","title":"Diagrama de casos d'\u00fas","text":"<p>El diagrama de casos d'\u00fas per al cas \"Consultar Pizzes\" mostrar\u00e0 l'actor principal (el client) i les interaccions amb el sistema per realitzar aquesta acci\u00f3.</p> <p>Es tractaria d'un diagrama bastant simple:</p> <p></p> <p>L'especificaci\u00f3 dels requeriments funcionals d'aquest cas d'\u00fas tindr\u00e0 el seg\u00fcent aspecte:</p>"},{"location":"Sprint1_Pizzes/#cas-dus-rf01","title":"Cas d'\u00fas: RF01","text":"<ul> <li>Nom: Consultar Pizzes  </li> <li>Actors: Client</li> <li>Descripci\u00f3: El client consulta el men\u00fa de pizzes disponibles a trav\u00e9s de la interf\u00edcie web.  </li> <li>Precondicions: El client ha d'accedir a la web.  </li> <li>Postcondicions: Es mostra la llista de pizzes o un missatge d'error si hi ha algun problema.  </li> </ul>"},{"location":"Sprint1_Pizzes/#flux-principal","title":"Flux principal","text":"<ol> <li>El client accedeix al sistema mitjan\u00e7ant el navegador.  </li> <li>El sistema mostra la llista de pizzes disponibles.  </li> </ol>"},{"location":"Sprint1_Pizzes/#fluxos-alternatius-excepcions","title":"Fluxos alternatius (excepcions)","text":"<ul> <li>Error de connexi\u00f3: El sistema mostra un missatge d'error si no es pot contactar amb el servidor.  </li> <li>Llista buida: Si no hi ha pizzes disponibles, s\u2019informa l'usuari que el men\u00fa est\u00e0 buit.  </li> </ul>"},{"location":"Sprint1_Pizzes/#diagrama-de-classes","title":"Diagrama de classes","text":"<p>El diagrama de classes ens permet identificar les classes necess\u00e0ries per implementar el cas d'\u00fas \"Consultar Pizzes\" i les relacions entre elles.</p> <p>Despr\u00e9s d'analitzar el cas d'\u00fas, identifiquem les seg\u00fcents classes:</p>"},{"location":"Sprint1_Pizzes/#1-classes-del-model-domini","title":"1. Classes del model (domini)","text":"<ul> <li><code>Pizza</code>: Representa una pizza amb les seues caracter\u00edstiques.  </li> <li><code>PizzaService</code>: Gestiona la comunicaci\u00f3 amb el servidor per obtenir la llista de pizzes.</li> </ul>"},{"location":"Sprint1_Pizzes/#2-classes-de-la-interficie-webcomponents","title":"2. Classes de la interf\u00edcie (WebComponents)","text":"<ul> <li><code>PizzaCard</code>: WebComponent que representa visualment una pizza.  </li> <li><code>PizzaList</code>: WebComponent que s'encarrega de mostrar la llista de pizzes rebuda.</li> <li><code>LlistaAlergens</code>: Per representar amb una etiqueta el que ser\u00e0 una llista d'imatges amb els diferents alergens.</li> </ul> <p>Notes</p> <ul> <li>Les classes d'interf\u00edcie es poden incloure en el diagrama general o b\u00e9 en un diagrama espec\u00edfic d'interf\u00edcie d'usuari. En aquest cas, les inclourem per entendre la interacci\u00f3 amb el model.  </li> <li>Per al diagrama de classes ens centrarem en la part del client, abstraient tota la part del servidor.</li> </ul>"},{"location":"Sprint1_Pizzes/#diagrama-de-classes-en-plantuml","title":"Diagrama de classes en PlantUML","text":""},{"location":"Sprint1_Pizzes/#que-hem-representat-aci","title":"Qu\u00e8 hem representat aci?","text":"<ol> <li>Model de dades: <code>Pizza</code> representa el model amb els seus atributs.  </li> <li>Gesti\u00f3 de la l\u00f2gica de negoci: <code>PizzaService</code> encapsula la l\u00f2gica per a la consulta de pizzes.</li> <li>Interf\u00edcie d'usuari: <code>PizzaCard</code> gestiona la presentaci\u00f3.  Com veiem, aquesta utilitza la classe Pizza, i \u00e9s una subclasse d'<code>HTMLElement</code>.</li> </ol> <p>Tingueu en compte que hem definit una entitat Main que realment vam implementar com un script. Ara b\u00e9, aix\u00f2 podria implementar-se com una classe, i seguir un model completament orientat a objectes.</p>"},{"location":"Sprint1_Pizzes/#diagrama-de-sequencia","title":"Diagrama de seq\u00fc\u00e8ncia","text":"<p>Aquest diagrama mostrar\u00e0 la seq\u00fc\u00e8ncia d'interaccions necess\u00e0ria perqu\u00e8 el client puga consultar les pizzes disponibles. </p> <p>El flux de la seq\u00fc\u00e8ncia ser\u00e0 el seg\u00fcent:</p> <ol> <li>El client carrega la p\u00e0gina i el codi de main.js inicia el proc\u00e9s.</li> <li>PizzaService fa una crida a l'API REST del Servidor.</li> <li>El Servidor consulta la base de dades i retorna la llista de pizzes.</li> <li>El PizzaService processa les dades i les retorna a main.js.</li> <li>main.js crea din\u00e0micament un PizzaCard per a cada pizza i l'insereix al DOM.</li> <li>Cada PizzaCard mostra la informaci\u00f3 de la pizza i, si cal, genera una llista d'al\u00e8rgens amb PizzaLlistaAlergens (aix\u00f2 ser\u00e0 en properes iteracions).</li> </ol> <p></p> <p>Observeu que s'ha afegit el renderitzat de la llista d'al\u00e8rgens, que haureu d'implementar vosaltres</p>"},{"location":"Sprint1_Pizzes/#diagrama-de-components","title":"Diagrama de components","text":"<p>El diagrama de components ens ajuda a visualitzar l'arquitectura del sistema i la interacci\u00f3 entre els diferents m\u00f2duls que el conformen. En aquest cas, reflectirem:  </p> <ul> <li>L'aplicaci\u00f3 client basada en WebComponents.  </li> <li>El servei de comunicaci\u00f3 amb l'API.  </li> <li>La interacci\u00f3 amb el servidor.  </li> </ul> <p>Els components principals de qu\u00e8 constar\u00e0 doncs l'aplicaci\u00f3 seran:</p> <ol> <li>M\u00f2dul <code>main.js</code>: </li> <li>Punt d'entrada de l'aplicaci\u00f3.  </li> <li> <p>Gestiona la creaci\u00f3 din\u00e0mica dels components.  </p> </li> <li> <p>M\u00f2dul <code>PizzaService</code>: </p> </li> <li> <p>Gestiona la comunicaci\u00f3 amb el servidor via <code>fetch</code>.  </p> </li> <li> <p>Components WebComponents: </p> </li> <li><code>PizzaCard</code>: Mostra les dades de cada pizza.  </li> <li> <p><code>PizzaLlistaAlergens</code>: Mostra gr\u00e0ficament els al\u00e8rgens.  </p> </li> <li> <p>API del servidor: </p> </li> <li>Serveix les dades a trav\u00e9s d'una crida <code>GET</code>.  </li> </ol> <p>El diagrama resultant ser\u00e0:</p> <p></p> <p>Com veiem, la part client cont\u00e9 b\u00e0sicament com a components les classes que hem generat anteriorment, i s'interact\u00faa ambel sistema del servidor a trav\u00e9s de l'API.</p> <p>Implementaci\u00f3</p> <p>Consulteu la implementaci\u00f3 d'aquest sprint</p>"},{"location":"Sprint4_Solucio/","title":"Sprint4 Solucio","text":""},{"location":"Sprint4_Solucio/#sprint-4-resolucio","title":"Sprint 4. Resoluci\u00f3.","text":""},{"location":"Sprint4_Solucio/#diagrama-de-casos-dus","title":"Diagrama de casos d'\u00fas","text":"<p>En aquest diagrama, incorporem els casos d'\u00fas per demanar begudes i processar la comanda.</p> <p></p>"},{"location":"Sprint4_Solucio/#especificacio-dels-requisits-funcionals","title":"Especificaci\u00f3 dels requisits funcionals","text":"<p>Els nous requeriments funcionals quedaran especificats de la seg\u00fcent manera:</p>"},{"location":"Sprint4_Solucio/#cas-dus-rf06-consultar-cataleg-de-begudes","title":"Cas d'\u00fas: RF06 - Consultar cat\u00e0leg de begudes","text":"<ul> <li>Nom: Consultar cat\u00e0leg de begudes  </li> <li>Actors: Client  </li> <li>Descripci\u00f3: El client pot accedir a la pestanya de begudes per veure la llista de begudes disponibles.  </li> <li>Precondicions: El client ha d'accedir a la web i veure el men\u00fa de productes.  </li> <li>Postcondicions: Es mostra la llista de begudes disponibles, incloent informaci\u00f3 com nom, preu i caracter\u00edstiques (sucre, cafe\u00efna, alcohol).  </li> </ul>"},{"location":"Sprint4_Solucio/#flux-principal","title":"Flux principal","text":"<ol> <li>El client accedeix a la pestanya de begudes.  </li> <li>El sistema obt\u00e9 la llista de begudes de l'API i genera les targetes corresponents.  </li> <li>El client visualitza les begudes disponibles.  </li> </ol>"},{"location":"Sprint4_Solucio/#fluxos-alternatius-excepcions","title":"Fluxos alternatius (excepcions)","text":"<ul> <li>Error en la c\u00e0rrega de dades: Si hi ha un problema en la comunicaci\u00f3 amb l'API, es mostra un missatge d'error.  </li> </ul> <p>Compte</p> <p>Ac\u00ed \u00e9s f\u00e0cil caure en l'error de voler enriquir els requisits amb la possibilitat d'afegir i eliminar begudes al carret.</p> <p>Cal tindre en compte que aquestes no s\u00f3n funcionalitats noves en aquest sprint, ja que estan cobertes pels casos d'\u00fas Afegir productes al carret i Eliminar Productes al carret.</p> <p>Aquests dos casos d'\u00fas s\u00f3n gen\u00e8rics, i ja inclouen qualsevol producte (pizzes, entrants, i ara begudes).</p>"},{"location":"Sprint4_Solucio/#cas-dus-rf07-processar-comanda","title":"Cas d'\u00fas: RF07 - Processar comanda","text":"<ul> <li>Nom: Processar comanda  </li> <li>Actors: Client  </li> <li>Descripci\u00f3: Quan el client ha completat la selecci\u00f3 de productes al carret, pot enviar la comanda a la pizzeria. El servidor confirma la recepci\u00f3 i retorna l'hora prevista d'arribada i el n\u00famero de comanda.</li> <li>Precondicions: El carret cont\u00e9 productes.</li> <li>Postcondicions: Si la comanda s'envia correctament, es mostra un missatge de confirmaci\u00f3 amb l'hora d'arribada i el n\u00famero de comanda, i s'elimina el contingut del carret. Si hi ha un error, es mostra un missatge d'error.</li> </ul>"},{"location":"Sprint4_Solucio/#flux-principal_1","title":"Flux principal","text":"<ol> <li>El client accedeix a la pestanya del carret.  </li> <li>El client fa clic en el bot\u00f3 \"Processar comanda\".  </li> <li>El sistema envia la comanda a l'API REST del servidor.</li> <li>L'API REST retorna una resposta amb la confirmaci\u00f3 de la comanda.  </li> <li>El sistema mostra la confirmaci\u00f3 de la comanda amb l'hora estimada d'arribada.  </li> <li>La comanda s'afegeix a l'hist\u00f2ric de comandes i el carret es buida.  </li> </ol>"},{"location":"Sprint4_Solucio/#fluxos-alternatius-excepcions_1","title":"Fluxos alternatius (excepcions)","text":"<ul> <li>Error en l'enviament: Si hi ha un problema en la comunicaci\u00f3 amb el servidor, es mostra un missatge d'error.  </li> <li>Comanda rebutjada: Si el servidor retorna un error, es mostra el missatge indicat per l'API.  </li> </ul> <p>A m\u00e9s, tenim com a extra el seg\u00fcent requisit per consultar l'hist\u00f2ric de comandes. Recordem que fins ara, aquest no ser\u00e0 persistent.</p>"},{"location":"Sprint4_Solucio/#cas-dus-rf08-consultar-historic-de-comandes","title":"Cas d'\u00fas: RF08 - Consultar hist\u00f2ric de comandes","text":"<ul> <li>Nom: Consultar hist\u00f2ric de comandes  </li> <li>Actors: Client  </li> <li>Descripci\u00f3: El client pot accedir a la pestanya d\u2019hist\u00f2ric de comandes per veure una llista de les comandes realitzades pr\u00e8viament.  </li> <li>Precondicions: Ha d'haver almenys una comanda processada.  </li> <li>Postcondicions: Es mostra la llista de comandes anteriors amb el n\u00famero de comanda, l\u2019hora d\u2019arribada i els productes de la comanda.  </li> </ul>"},{"location":"Sprint4_Solucio/#flux-principal_2","title":"Flux principal","text":"<ol> <li>El client accedeix a la pestanya d\u2019hist\u00f2ric de comandes.  </li> <li>Es mostren les comandes realitzades en la sessi\u00f3 actual en format de targeta amb la informaci\u00f3 corresponent.  </li> </ol> <p>Nota: L'hist\u00f2ric de comandes nom\u00e9s es mant\u00e9 durant l'execuci\u00f3 de l'aplicaci\u00f3. No es guarda en cap base de dades ni emmagatzemament local, de manera que no persisteix quan es recarrega la p\u00e0gina.</p>"},{"location":"Sprint4_Solucio/#fluxos-alternatius-excepcions_2","title":"Fluxos alternatius (excepcions)","text":"<ul> <li>Hist\u00f2ric buit: Si encara no s\u2019ha realitzat cap comanda en la sessi\u00f3 actual, no es mostra res en l'hist\u00f2ric.  </li> <li>Error en la c\u00e0rrega de dades: Si hi ha un problema en la consulta, es mostra un missatge d\u2019error.  </li> </ul>"},{"location":"Sprint4_Solucio/#diagrama-de-classes","title":"Diagrama de classes","text":"<p>El diagrama de classes, en la seua versi\u00f3 m\u00e9s senzilla es mostra de la seg\u00fcent manera:</p> <p></p> <p>Algunes reflexions sobre persist\u00e8ncia i gesti\u00f3 de l'estat</p> <p>En aquest punt, \u00e9s f\u00e0cil confondre dos conceptes que hem esmentat per\u00f2 no hem treballat produndament: la gesti\u00f3 de l'estat i la persist\u00e8ncia.</p> <ul> <li>Gesti\u00f3 de l\u2019estat: mecanisme que mant\u00e9 informaci\u00f3 temporal durant l'execuci\u00f3 de l'aplicaci\u00f3, com per exemple, el contingut del carret.</li> <li>Persist\u00e8ncia: Guarda informaci\u00f3 entre sessions perqu\u00e8 no es perda en recarregar l'aplicaci\u00f3 (com per exemple un hist\u00f2ric de comandes que volguerem emmagatzemar)</li> </ul> <p>Com veiem, estracta de conceptes diferents, tot i que estan relacionats:</p> <ul> <li>L\u2019estat es guarda en mem\u00f2ria mentre l\u2019aplicaci\u00f3 est\u00e0 oberta,</li> <li>La persist\u00e8ncia ens permetria restaurar l'estat despr\u00e9s de tancar i tornar a obrir l'aplicaci\u00f3.</li> <li>En moltes ocasions, \u00e9s interessant oferir persist\u00e8ncia a l'estat. En l'exemple que estem veient, podriem voler mantenir el carret persistent si es refresca la p\u00e0gina, per\u00f2 tenim molts altres exemples, com mantenir les pantalles que teniem superades en un videojoc o les converses iniciades en una aplicaci\u00f3 de missatgeria.</li> </ul> <p>En aquest exemple, no es demana incorporar persist\u00e8ncia en cap lloc. Si volguerem guardar l'hist\u00f2ric de comandes, podriem fer-ho en local, en el propi navegador fent \u00fas del <code>localStorage</code>, o directament en el servidor, on ja caldria incorporar gesti\u00f3 d'usuaris per associar les comandes, etc, i l'arquitectura potser se'ns complicaria una miqueta.</p> <p>Un component per a l'hist\u00f2ric?</p> <p>Un altre punt que podr\u00edem discutir \u00e9s si incorporar o no un nou component a la interf\u00edcie per a l'hist\u00f2ric. En Sprints anteriors, per a l'apartat de les pizzes, els entrants i ara les begudes, no hem utilitzat cap tipus de component espec\u00edfic per a aquests, per\u00f2 s\u00ed que ho hem fet per al carret. Per qu\u00e8?</p> <p>El motiu \u00e9s que el carret t\u00e9 un comportament espec\u00edfica, i per exemple, ha d'estar pendent de quan s'afig o s'elimina algun producte per actualitzar-se, per\u00f2 en la resta de casos no. </p> <p>Per al cas de l'hist\u00f2ric de comandes, si no va a tindre cap comportament especial, podem ignorar aquest component.</p> <p>No obstant aix\u00f2, i per tal de millorar-ne la modularitat i possibles amplicacions, podria plantejar-se incorporar un component espec\u00edfic per a l'hist\u00f2ric (i fins i tot, tamb\u00e9 components per a les begudes, pizzess o entrants!)</p> <p>Tenint en compte les dues anotacions anteriors, en cas que volguerem afegir aquesta persist\u00e8ncia, i a m\u00e9s, afegir un WebComponent per mostrar l'historial, en lloc de fer-ho en un div directament, implementar\u00edem les seg\u00fcents classes.</p> <p></p> <p>Amb aix\u00f2 tenim:</p> <ul> <li>Una nova classe <code>GestorPersist\u00e8ncia</code> per gestionar l'emmagatzemament (p. ex. en localStorage)</li> <li>Ara <code>Carret</code>  tindr\u00e0 els m\u00e8todes <code>guardarCarret()</code> i <code>carregarCarret()</code> per poder recuperar l'estat despr\u00e9s de reiniciar l'aplicaci\u00f3.</li> <li>Hem afegir un <code>GestorPersist\u00e8ncia</code> que gestiona tant la persist\u00e8ncia del carret com la de les comandes.</li> <li>Hem afegit el component <code>HistorialComponent</code> qeue encapsula la visualitzaci\u00f3 de comandes guardades.</li> </ul>"},{"location":"Sprint4_Solucio/#diagrames-de-sequencia","title":"Diagrames de seq\u00fc\u00e8ncia","text":"<p>Una vegada definit el diagrama de classes, podem abordar els diagrames de seq\u00fc\u00e8ncia seguint la mateixa estructura que hem utilitzat en els sprints anteriors.</p> <p>Generarem doncs els diagames de seq\u00fc\u00e8ncia per a :</p> <ul> <li>Consultar el cat\u00e0leg de begudes, que indicar\u00e0 com es carrega i es mostra la llista de begudes,</li> <li>Processar una comanda, on veurem com s'envia la comanda al servidor i mostrar la resposta.</li> </ul> <p>I tot i que no es demanava, vaurem tamb\u00e9 el diagrama per consultar l'hist\u00f2ric de comades.</p>"},{"location":"Sprint4_Solucio/#diagrama-de-sequencia-consultar-el-cataleg-de-begudes","title":"Diagrama de seq\u00fc\u00e8ncia: Consultar el cat\u00e0leg de begudes","text":""},{"location":"Sprint4_Solucio/#diagrama-de-sequencia-processar-una-comanda","title":"Diagrama de seq\u00fc\u00e8ncia: Processar una comanda","text":""},{"location":"Sprint4_Solucio/#diagrama-de-sequencia-consultar-lhistoric-de-comandes","title":"Diagrama de seq\u00fc\u00e8ncia: Consultar l\u2019hist\u00f2ric de comandes","text":""},{"location":"Sprint4_Solucio/#diagrama-de-components","title":"Diagrama de components","text":"<p>Els diagrames de components tenen com a objectiu mostrar l'arquitectura d'alt nivell d'una aplicaci\u00f3, representant com es relacionen els diferents components entre si i com interactuen amb els serveis externs. No obstant aix\u00f2, quan el sistema creix i incorpora molts elements, el diagrama pot convertir-se en massa complex i dif\u00edcil de llegir.</p> <p>En el diagrama anterior s'han reflexat totes les connexions entre els components del sistema, incloent la creaci\u00f3 de cadascun per part del fitxer principal (main.js) i totes les interaccions directes entre ells.</p> <p>Aquest diagrama presenta alguns problemes per poder interpretar-lo a primera vista:</p> <ul> <li>T\u00e9 massa connexions, fent que el flux d\u2019informaci\u00f3 siga dif\u00edcil de seguir.</li> <li>El fitxer main.js est\u00e0 representat per crear cada component, quan en realitat aix\u00f2 no aporta informaci\u00f3 rellevant en quant a l'arquitectura.</li> <li>Les connexions entre components que ja s\u2019entenen impl\u00edcitament (com <code>CounterComponent</code> dins de <code>PizzaCard</code>) no caldria dibuixar-les expl\u00edcitament.</li> </ul> <p>Aix\u00ed doncs, \u00e9s preferible treballar amb una simplificaci\u00f3 d'aquest diagrama, que millore la legibilitat i ens ajude a entendre millor l'arquitectura del sistema. </p> <p>Veiem com quedaria:</p> <p></p> <p>En aquest diagrama, ara es reflexa principalment els diferents components que formen l'arquitectura de l'aplicaci\u00f3 (interf\u00edcie, serveis, gesti\u00f3 de l'estat). Com veiem, hem eliminat el main.js, hem reduit les connexions directes, i nom\u00e9s hem mostrat les depend\u00e8ncies m\u00e9s rellevants. Si alguna cosa requereix d'alguna aclaraci\u00f3, podem fer \u00fas de notes per explicar els diferents conceptes o explicar relacions sense afegir m\u00e9s l\u00ednies.</p>"},{"location":"_kk_7.Exercicis/","title":"kk 7.Exercicis","text":""},{"location":"_kk_7.Exercicis/#casos-practics","title":"Casos pr\u00e0ctics","text":""},{"location":"_kk_7.Exercicis/#sistema-de-reserves-esportives","title":"Sistema de reserves esportives","text":"<p>Anem a realitzar un sistema de reserves en l\u00ednia per a un centre esportiu, que ofereix serveis com la reserva de pistes, la gesti\u00f3 d\u2019usuaris i la generaci\u00f3 de factures. Per a aix\u00f2, realitzarem tres, els quals faran evolucionar els diferents diagrames UML utilitzats.</p>"},{"location":"_kk_7.Exercicis/#objectiu-general-del-projecte","title":"Objectiu general del projecte:","text":"<p>7.Exercicis Desenvolupar una aplicaci\u00f3 que permeta als usuaris reservar pistes esportives, gestionar les seues reserves i generar factures.</p>"},{"location":"_kk_7.Exercicis/#sprint-1-sistema-basic-de-reserves","title":"Sprint 1: Sistema b\u00e0sic de reserves","text":"<p>Objectiu del sprint: </p> <p>Permetre als usuaris reservar una pista esportiva.</p>"},{"location":"_kk_7.Exercicis/#requeriments-identificats","title":"Requeriments identificats:","text":"<ul> <li>Els usuaris han de poder veure les pistes disponibles.</li> <li>Han de poder reservar una pista concreta.</li> <li>El sistema ha de guardar la reserva.</li> </ul> <p>Diagrames de casos d'\u00fas</p>"},{"location":"_kk_7.Exercicis/#diagrama-de-casos-dus-plantuml","title":"\ud83d\uddbc\ufe0f Diagrama de casos d'\u00fas (PlantUML)","text":""},{"location":"_kk_7.Exercicis/#diagrama-de-classes-inicial-plantuml","title":"\ud83d\udee0\ufe0f Diagrama de classes inicial (PlantUML)","text":""},{"location":"_kk_7.Exercicis/#diagrama-de-sequencia-plantuml","title":"\ud83d\udd04 Diagrama de seq\u00fc\u00e8ncia (PlantUML)","text":""},{"location":"_kk_7.Exercicis/#sprint-2-afegim-gestio-dusuaris","title":"\ud83d\udcc8 Sprint 2: Afegim gesti\u00f3 d'usuaris","text":"<p>Objectiu del sprint: Permetre que els administradors puguen gestionar els usuaris i diferenciar entre tipus d'usuari.</p>"},{"location":"_kk_7.Exercicis/#requeriments-identificats_1","title":"\ud83d\udd39 Requeriments identificats:","text":"<ul> <li>Els administradors han de poder afegir i eliminar usuaris.  </li> <li>Cal distingir entre usuaris normals i administradors.  </li> </ul>"},{"location":"_kk_7.Exercicis/#diagrama-de-casos-dus-actualitzat-plantuml","title":"\ud83d\uddbc\ufe0f Diagrama de casos d'\u00fas actualitzat (PlantUML)","text":""},{"location":"_kk_7.Exercicis/#diagrama-de-classes-actualitzat-plantuml","title":"\ud83d\udee0\ufe0f Diagrama de classes actualitzat (PlantUML)","text":""},{"location":"_kk_7.Exercicis/#diagrama-de-sequencia-actualitzat-plantuml","title":"\ud83d\udd04 Diagrama de seq\u00fc\u00e8ncia actualitzat (PlantUML)","text":""},{"location":"_kk_7.Exercicis/#sprint-3-afegim-facturacio","title":"\ud83d\udd0d Sprint 3: Afegim facturaci\u00f3","text":"<p>Objectiu del sprint: Implementar la generaci\u00f3 i gesti\u00f3 de factures per a les reserves realitzades.</p>"},{"location":"_kk_7.Exercicis/#requeriments-identificats_2","title":"\ud83d\udd39 Requeriments identificats:","text":"<ul> <li>El sistema ha de generar una factura despr\u00e9s de fer una reserva.  </li> <li>Els administradors han de poder consultar les factures.  </li> </ul>"},{"location":"_kk_7.Exercicis/#diagrama-de-casos-dus-final-plantuml","title":"\ud83d\uddbc\ufe0f Diagrama de casos d'\u00fas final (PlantUML)","text":""},{"location":"_kk_7.Exercicis/#diagrama-de-classes-final-plantuml","title":"\ud83d\udee0\ufe0f Diagrama de classes final (PlantUML)","text":""},{"location":"_kk_7.Exercicis/#diagrama-de-sequencia-final-plantuml","title":"\ud83d\udd04 Diagrama de seq\u00fc\u00e8ncia final (PlantUML)","text":""},{"location":"_kk_7.Exercicis/#reflexio-del-proces","title":"\u2705 Reflexi\u00f3 del proc\u00e9s","text":"<p>Aquest cas pr\u00e0ctic mostra com:</p> <ol> <li>El disseny UML es pot desenvolupar iterativament. </li> <li>Cada sprint amplia i actualitza els diagrames per incorporar les noves funcionalitats.  </li> <li>PlantUML permet representar f\u00e0cilment els canvis amb diagrames de casos d'\u00fas, classes i seq\u00fc\u00e8ncies.  </li> </ol> <p>Amb aquesta metodologia, UML s'integra de manera natural amb SCRUM i altres metodologies \u00e0gils, adaptant-se a les necessitats del projecte a cada iteraci\u00f3.</p>"},{"location":"composicionsJava/","title":"composicionsJava","text":""},{"location":"composicionsJava/#composicions-en-java","title":"Composicions en Java","text":"<p>Anem a veure com fariem l'exemple de la partida en Java. Com representar\u00edeu que una partida pot tindre m\u00e9s d'un jugador? Anem a veure alguna forma de representar-ho amb estructures de dades que ens proporciona Java.</p> <p>En primer lloc, definiriem la classe <code>Jugador</code>:</p> <pre><code>public class Jugador {\n\n  private String Nom;  \n\n  public Jugador () { };\n\n  public void setNom (String newVar) {\n    Nom = newVar;\n  }\n\n  public String getNom () {\n    return Nom;\n  }\n}\n</code></pre> <p>Com veiem, \u00e9s una classe senzilla, on definim l'atribut Nom i els m\u00e8todes accessors necessaris. Anem a veure ara com fer la classe Partida:</p> <pre><code>import java.Util.ArrayList;\n\npublic class Partida {\n\n  private int idPartida;\n\n  // Definim Jugadors com a una llista \n  // implementada com un vector (ArrayList)\n  // d'objectes de tipus *Jugador*\n  private ArrayList&lt;Jugador&gt; Jugadors;\n\n  public Partida () {\n      // En el constructor de la partida, creem\n      // aquest ArrayList.\n      this.Jugadors = new ArrayList&lt;Jugador&gt;();\n  };\n\n  public void setIdPartida (int newVar) {\n    idPartida = newVar;\n  }\n\n  public int getIdPartida () {\n    return idPartida;\n  }\n\n  public void setJugadors (String Nom) {\n    // Per afegir un nou jugador donat el nom\n    // el crearem i l'afegirem a l'ArrayList:\n\n    Jugador nouJugador=new Jugador();\n    nouJugador.setNom(Nom);\n    // Per afegir-lo, utilitzem el m\u00e8tode add\n    // de l'arraylist\n    this.Jugadors.add(nouJugador);\n  }\n\n  public Jugador getJugadors () {\n    return this.Jugadors;\n  }\n\n  public void iniciarPartida()\n  {\n  }\n  public void finalitzarPartida()\n  {\n  }\n\n}\n</code></pre> <p>Analitzem un poc l'exemple. Hem introdu\u00eft el tipus de dada <code>ArrayList</code>, definit a la llibreria <code>java.Utils</code>, i hem definit dins la classe <code>Partida</code> un <code>ArrayList</code> d'objectes de tipus <code>Jugador</code>:</p> <pre><code>public class Partida {\n...\n  private ArrayList&lt;Jugador&gt; Jugadors;\n  ...\n</code></pre> <p>La forma de declarar un <code>ArrayList</code> en general t\u00e9 la seg\u00fcent sintaxi:</p> <pre><code>ArrayList&lt;TipusBase&gt; NomDelArrayList;\n</code></pre> <p>Recordem que un <code>ArrayList</code> \u00e9s una llista, que internament s'implementa com un vector, per\u00f2 la qual ens ofereix m\u00e8todes com <code>add</code>, <code>remove</code>, <code>set</code> o <code>get</code> per crear, eliminar, modificar o consultar elements, sense preocupar-nos de la gesti\u00f3 dels \u00edndex interna del vector.</p> <p>Quan definim un <code>ArrayList</code>, hem d'indicar el tipus de dades que aquest contindr\u00e0 (el seu TipusBase). Aquest podr\u00e0 ser enter, cadenes de car\u00e0cters... o altra classe, com \u00e9s el nostre cas, que es tracta d'objectes de tipus <code>Jugador</code>.</p> <p>Amb aix\u00f2, hem definit l'<code>ArrayList</code>, per\u00f2 aquest no t\u00e9 encara espai reservat en mem\u00f2ria per a ell. Per a aix\u00f2, haurem de crear-lo dins el constructor de la classe partida. \u00c9s a dir, quan creem una partida, haurem de crear l'<code>ArrayList</code> que contindr\u00e0 la llista (bu\u00efda de moment) de jugadors.</p> <p>Per tal de fer aix\u00f2, al constructor, farem:</p> <pre><code>  public Partida () {\n      this.Jugadors = new ArrayList&lt;Jugador&gt;();\n  };\n</code></pre> <p>Simplement, hem hagut de crear l'<code>ArrayList</code> de <code>Jugadors</code> i assignar-lo a <code>this.Jugadors</code>.</p> <p>Ara ens queda per vore com afegim jugadors a la partida. Per a aix\u00f2, anem a veure el m\u00e8tode <code>setJugadors</code>:</p> <pre><code>  public void setJugadors (String Nom) {\n    // Per afegir un nou jugador donat el nom\n    // el crearem i l'afegirem a l'ArrayList:\n\n    Jugador nouJugador=new Jugador();\n    nouJugador.setNom(Nom);\n    // Per afegir-lo, utilitzem el m\u00e8tode add\n    // de l'arraylist\n    this.Jugadors.add(nouJugador);\n  }\n</code></pre> <p>Com veiem, al m\u00e8tode ens passen el nom del jugador, i \u00e9s el propi m\u00e8tode <code>setJugadors</code>, qui crea un nou objecte (<code>nouJugador</code>) de tipus <code>Jugador</code>, i l'afig a l'<code>ArrayList</code> mitjan\u00e7ant el m\u00e8tode <code>add</code> que aquest ens proporciona.</p> <p>Fixeu-vos que quan destru\u00efm la partida, l'ArrayList tamb\u00e9 es destru\u00efr\u00e0, i amb ell, tots els jugadors que s'han creat (a trav\u00e9s del recol\u00b7lector de fem). Aquest \u00e9s el comportament corresponent a una composici\u00f3.</p> <p>Si en aquest cas haverem volgut representar una associaci\u00f3 en lloc de la composici\u00f3, podriem haver definit el m\u00e8tode <code>setJugador</code> de la seg\u00fcent forma:</p> <pre><code>public void setJugadors (Jugador jugador) {\n    this.Jugadors.add(jugador);\n  }\n</code></pre> <p>Fixeu-vos que en aquest cas, en lloc de rebre com a argument el nom del jugador, rebem ja una inst\u00e0ncia de jugador, el que vol dir que aquest objecte s'ha creat fora, i el que rebem, realment \u00e9s una refer\u00e8ncia a aquest. En aqest cas, quan s'elimine la <code>Partida</code>, s'eliminar\u00e0 l'ArrayList de jugadors, junt amb les inst\u00e0ncies a aquest, per\u00f2 no s'eliminaran els objectes de tipus <code>Jugador</code>, ja que segueixen existint fora d'aquesta classe (estan referenciats en algun lloc, i el recol\u00b7lector de fem no els elimina).</p>"}]}